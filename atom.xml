<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知乐园</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://anshenzheng.github.io/"/>
  <updated>2019-03-31T10:40:18.688Z</updated>
  <id>https://anshenzheng.github.io/</id>
  
  <author>
    <name>Annan An</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java知识梳理系列一 - JVM内存结构</title>
    <link href="https://anshenzheng.github.io/2019/03/31/Java%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E7%B3%BB%E5%88%97%E4%B8%80-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>https://anshenzheng.github.io/2019/03/31/Java知识梳理系列一-JVM内存结构/</id>
    <published>2019-03-31T08:55:13.331Z</published>
    <updated>2019-03-31T10:40:18.688Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>JVM是Java程序运行的平台，了解JVM的内存结构有助于开发者对Java程序运行期间内存的分配，回收，以及运行原理等有一个清晰的认识，从而方便开发者在生产中遇到性能问题或者内存溢出等问题时有的放矢，快速定位并解决问题。</p><p>首先用一张图来展示JVM的内存结构模型：<br><img src="https://github.com/Anshenzheng/ImageStore/blob/master/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B.jpg?raw=true" alt=""></p><p>JVM内存主要分为以下几个区域</p><h3 id="Java堆区-Heap"><a href="#Java堆区-Heap" class="headerlink" title="Java堆区(Heap)"></a>Java堆区(Heap)</h3><p>Java堆区用于存放对象实例，几乎所有的对象实例都会在这里分配。<br>一般来说，Java堆区是Java虚拟机所管理的内存中最大的一块，是被所有线程共享的内存区域，在虚拟机启动时创建。</p><blockquote><p>如果堆中没有足够的内存完成实例分配并且也无法再扩展时，将会抛出OutOfMemoryError异常。</p></blockquote><h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h3><p>方法区用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码数据等等。<br>方法区也是各个线程共享的内存区域。</p><blockquote><p>当方法区无法满足内存分配需求时，将会抛出OutOfMemoryError异常。</p></blockquote><h3 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h3><p>程序计数器是用于记录当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的指令。<br>程序计数器为线程私有，每条线程都需要一个独立的程序计数器，这样线程切换后就可以恢复到正确的执行位置。</p><blockquote><p>程序计数器是唯一一个不会会抛出OutOfMemoryError异常的区域。</p></blockquote><h3 id="虚拟机栈-JVM-Stacks"><a href="#虚拟机栈-JVM-Stacks" class="headerlink" title="虚拟机栈(JVM Stacks)"></a>虚拟机栈(JVM Stacks)</h3><p>虚拟机栈是描述Java方法执行的内存模型，每个方法被执行时都会创建一个栈帧用于存储局部变量表、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。<br>Java虚拟机栈也是线程私有。</p><blockquote><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，如果虚拟机栈无法申请到足够的内存时会抛出OutOfMemoryError异常。</p></blockquote><h3 id="本地方法栈-Native-Methods-Stacks"><a href="#本地方法栈-Native-Methods-Stacks" class="headerlink" title="本地方法栈(Native Methods Stacks)"></a>本地方法栈(Native Methods Stacks)</h3><p>本地方法栈与虚拟机栈作用类似，主要用于执行Native方法服务。<br>本地方法栈也是线程私有。</p><blockquote><p>与虚拟机栈一样，也会抛出StackOverflowError异常和OutOfMemoryError异常。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;JVM是Java程序运行的平台，了解JVM的内存结构有助于开发者对Java程序运行期间内存的分配，回收，以及运行原理等有一个清晰的认识，从而方便开发者在生产中遇到性能问题或者
      
    
    </summary>
    
      <category term="后端" scheme="https://anshenzheng.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://anshenzheng.github.io/tags/Java/"/>
    
      <category term="虚拟机" scheme="https://anshenzheng.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="JVM" scheme="https://anshenzheng.github.io/tags/JVM/"/>
    
      <category term="内存" scheme="https://anshenzheng.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>CPS信息物理融合系统</title>
    <link href="https://anshenzheng.github.io/2019/01/01/CPS%E4%BF%A1%E6%81%AF%E7%89%A9%E7%90%86%E8%9E%8D%E5%90%88%E7%B3%BB%E7%BB%9F/"/>
    <id>https://anshenzheng.github.io/2019/01/01/CPS信息物理融合系统/</id>
    <published>2019-01-01T05:30:15.000Z</published>
    <updated>2019-01-01T07:29:43.972Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="https://github.com/Anshenzheng/ImageStore/blob/master/cps.png?raw=true" alt=""></p><h3 id="CPS基本概念"><a href="#CPS基本概念" class="headerlink" title="CPS基本概念"></a>CPS基本概念</h3><p>CPS是一种大规模、分布式、异构、复杂的，以及深度嵌入式的实时系统，是目前最前沿的交叉研究领域之一，涉及计算科学、网络技术、控制理论等多个学科，被普遍认为是计算机信息处理技术史上的下一次革命。<br>Internet改变了人与人之间的交互方式，CPS将会改变人与现实物理世界之间的交互方式。</p><p>CPS由传感器节点、执行器节点、传感与执行器组合节点、计算系统和控制系统组成。</p><blockquote><p>传感器节点、执行器节点、传感器与执行器组合节点分布在物理世界，实现对物理世界直接感知，并通过操作物理世界的对象正确的控制物理世界。<br>计算系统完成CPS要求的各种计算任务，提供各种服务，确定对物理世界的控制策略，协调各个执行器对物理世界的对象执行正确操作，实行对物理世界的协同控制。</p></blockquote><p>CPS的通信网络可以逻辑地视为由传感器网络、执行器网络、计算机网络构成的组合通信网络。<br><img src="http://file.elecfans.com/web1/M00/4F/3F/o4YBAFrWqg-AfLLPAACQr2mme60266.jpg" alt=""></p><h3 id="CPS-目标"><a href="#CPS-目标" class="headerlink" title="CPS 目标"></a>CPS 目标</h3><p>CPS的目标就是实现信息系统和物理世界以及各信息系统之间的深度融合：<br>在感知、互联互通、能力开放、安全可控、应用计算的基础上，构建出一个巨大的、融合的、智能化的生产服务系统。</p><h3 id="CPS的特点"><a href="#CPS的特点" class="headerlink" title="CPS的特点"></a>CPS的特点</h3><p>紧密融合<br>资源受限<br>网络复杂<br>异构异质<br>认知困难<br>时空约束<br>不确定性<br>安全可靠</p><h3 id="嵌入式系统-Vs-物联网-Vs-传感网-Vs-CPS"><a href="#嵌入式系统-Vs-物联网-Vs-传感网-Vs-CPS" class="headerlink" title="嵌入式系统 Vs 物联网 Vs 传感网 Vs CPS"></a>嵌入式系统 Vs 物联网 Vs 传感网 Vs CPS</h3><h4 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a>嵌入式系统</h4><p>嵌入式系统是软硬件的综合体，某些情况下还包括机械装置。<br>传统的物理设备通过嵌入式系统来扩展或增加新功能，其形成的系统基本上是封闭的系统。</p><h4 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h4><p>物联网的概念在1999年已经提出，其定义是通过射频识别，、红外感应器、全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物品与互联网连接起来，进行信息交换和通讯，以实现智能化识别、定位、跟踪、监控和管理的一种网络。物联网的核心和基础仍然是互联网，是在互联网基础的延伸和扩展的网络，在物联网中，用户端延伸和扩展到了任何物品和物品之间，进行信息交换和通讯。</p><h4 id="传感网-Sensor-Network"><a href="#传感网-Sensor-Network" class="headerlink" title="传感网(Sensor Network)"></a>传感网(Sensor Network)</h4><p>传感网节点是传感器，通过自组织的方式构成无线网络，感知的对象是诸如温度、湿度、噪声、网强度、压力、土壤成分、移动物体的大小、速度和方向等物理属性，实现特定区域的检测。</p><h4 id="CPS"><a href="#CPS" class="headerlink" title="CPS"></a>CPS</h4><p>CPS简单的说就是开放的嵌入式系统加上网络和控制功能，其核心是3C融合、自主适应物理环境的变化，其中网络的功能主要是为了实现控制的目的。物联网、传感网所擅长的是基于无线连接，主要实现的是感知，这对CPS来说太过简单，CPS需实现的是感控，不仅仅实现感知功能，还需要实现控制，其对计算能力的要求远远超过了物联网和传感网。</p><h3 id="发展现状"><a href="#发展现状" class="headerlink" title="发展现状"></a>发展现状</h3><p>目前国际上CPS研究工作刚刚开始，研究工作近涉及少数几个方面。<br>现有研究工作分为7类：<br>CPS的系统模型<br>CPS上数据传输与管理技术<br>CPS的能源管理<br>CPS的系统安全<br>CPS软件设计技术<br>CPS控制<br>CPS应用系统</p><h3 id="CPS应用范围"><a href="#CPS应用范围" class="headerlink" title="CPS应用范围"></a>CPS应用范围</h3><p>从微笑的纳米机器人，到庞大的工程基建设备，从城市交通信息提供到远程手术医疗系统，交通、医疗、农业、能源、国防、建筑、制造业流水线都是其涉足的领域。目前来看，CPS更偏重于科学研究， M2M、IOT更注重于工程技术的落地。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/Anshenzheng/ImageStore/blob/master/cps.png?raw=true&quot; alt=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTPS Basic</title>
    <link href="https://anshenzheng.github.io/2018/10/23/HTTPS%E8%AE%A4%E8%AF%81/"/>
    <id>https://anshenzheng.github.io/2018/10/23/HTTPS认证/</id>
    <published>2018-10-23T11:14:41.000Z</published>
    <updated>2018-12-18T14:54:21.504Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542553667416&amp;di=265e20c12afd5f9e5cc9c98e7bef1575&amp;imgtype=0&amp;src=http%3A%2F%2Ftxt6.book118.com%2F2016%2F1203%2Fbook67956%2F67955260.jpg" alt=""><br>目前网上有特别多的关于HTTPS认证的文章，但是很多讲的都比较笼统，要么也只介绍了其中一部分。本文旨在提供一个简单全面的关于认证的介绍，方便广大读者在短时间内能对HTTPS有一个全面深层次的认识和理解。</p><p>本文会从一下几方面讲解HTTPS认证的相关内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 基础概念</span><br><span class="line"><span class="number">1.1</span> 加密 Vs Hash</span><br><span class="line"><span class="number">1.2</span> 对称加密 Vs 非对称加密</span><br><span class="line"><span class="number">3</span>. SSL/TLS</span><br><span class="line"><span class="number">4</span>. CA</span><br><span class="line"><span class="number">4.1</span> CA Sample</span><br><span class="line"><span class="number">4.2</span> CA Apply</span><br><span class="line"><span class="number">4.3</span> CA Validation</span><br><span class="line"><span class="number">5</span>. HTTPS 单向认证</span><br><span class="line"><span class="number">6</span>. HTTPS 双向认证</span><br><span class="line"><span class="number">7</span>. 应用</span><br><span class="line"><span class="number">7.1</span> Keytool</span><br><span class="line"><span class="number">7.2</span> keystore Vs trustsotre</span><br><span class="line"><span class="number">7.3</span> Configure HTTPS in Tomcat</span><br><span class="line"><span class="number">8</span>. 其它</span><br><span class="line"><span class="number">8.1</span> Base64</span><br><span class="line"><span class="number">8.2</span> SSH</span><br></pre></td></tr></table></figure><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="加密-Vs-Hash"><a href="#加密-Vs-Hash" class="headerlink" title="加密 Vs Hash"></a>加密 Vs Hash</h4><p><strong>加密技术</strong>是利用技术手段和算法，把重要的数据加密后转化为乱码，传送到目的地后再通过相同或不同的手段还原。<br>加密前的内容成为<strong>明文</strong>，加密后的内容成为<strong>密文</strong>。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542554072256&amp;di=1f3606af7e71592397fe7e9eece12e8f&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.68686686.com%2FFile%2FArticle%2F20180604%2F3c51813d-88ac-404e-982e-61e32cff53be.png" alt=""><br><strong>Hash</strong>，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。</p><h4 id="对称加密-Vs-非对称加密"><a href="#对称加密-Vs-非对称加密" class="headerlink" title="对称加密 Vs 非对称加密"></a>对称加密 Vs 非对称加密</h4><p><strong>对称加密</strong>是采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542554786081&amp;di=27a509dabd1c4438fa1b6c61ed4016b2&amp;imgtype=0&amp;src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2Fee3f2fefc213e5a130bc6226f4ca151e.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100" alt=""></p><blockquote><p>流行的对称加密算法有DES, Triple-DES, RC2 和 RC4. </p></blockquote><p><strong>非对称加密</strong>算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542554526011&amp;di=c415dd72f654a4166844cdd040b96563&amp;imgtype=0&amp;src=http%3A%2F%2Fme2xp.blog.51cto.com%2Fattachment%2F201408%2F3%2F6716920_1407061378m5RW.jpg" alt=""></p><h3 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h3><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542555251822&amp;di=1ff2554f8ee8295abd2c89c3880f70ec&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20161128%2F85e401b1b4a247f0896376ad5281d30b_th.jpeg" alt=""><br>SSL是Netscape公司发明的一种用于WEB安全传输协议。随着时间推移由于Netscape失去市场份额，它将SSL的维护工作移交给了因特网工程任务组(IETF),后被重新命名为TLS。</p><h4 id="SSL协议功能"><a href="#SSL协议功能" class="headerlink" title="SSL协议功能"></a>SSL协议功能</h4><ul><li>数据传输保密性</li><li>数据传输完整性</li><li>通信双方身份认证</li></ul><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542560107542&amp;di=3a5ac3f2efe7ecc5296a3c668a6d8935&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20171026%2Feb0081c7ce4e4fd590ae16352af28389.jpeg" alt=""></p><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>由一个可信任的组织验证和签发的识别信息,是包含公钥、订阅人相关信息以及证书颁发者数字签名的数字文件，也就是一个让我们可以交换、存储和使用的公钥的壳。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542554408499&amp;di=5a5656f355ac071d9bede5d4833ef944&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.debugrun.com%2Fpic%2F2017%2F7%2F19%2Fea29a4644bfa0e5fa5ae246a85d5a8e6.jpg" alt=""></p><h4 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h4><p>在大多数情况下，仅仅有最终实体证书是无法进行有效性验证的，所以在实践中，服务器需要提供证书链才能一步步最终验证到可信根证书。<br><img src="https://ask.qcloudimg.com/http-save/developer-news/w3xn200qg9.jpeg" alt=""><br>如果根CA被吊销，所有使用CA签发出来的证书的网站都会无法正常访问。Baseline Requirements限制所有的根证书密钥必须离线保存，只能由人手动执行命令，直接由根证书签发最终实体证书是不允许的。<br>与根证书不同，二级CA一般都是在线的，而且使用自动化系统签发证书。</p><blockquote><p>服务器一次只能提供一条证书链</p></blockquote><h4 id="信赖方"><a href="#信赖方" class="headerlink" title="信赖方"></a>信赖方</h4><p>信赖方为了能够验证证书，必须收集新人的所有根CA证书。大多数操作系统都提供一个根证书库，从而在一开始启动的时候就能建立信任。几乎所有的软件开发者都重用了底层操作系统提供的根证书库，唯一例外的是Mozilla，为了保证不同平台的兼容性，它维护了自己的根证书库。</p><ul><li><p>Apple<br>Apple维护的根证书库主要是给IOS和OSX平台使用。</p></li><li><p>Chrome<br>在LINUX上, Chrome只用Mozilla的根证书库，除此之外都是依赖操作系统的证书库。</p></li><li><p>Microsoft<br>Microsoft维护的根证书库主要是给Windows桌面版、服务器以及移动手机平台使用。</p></li><li><p>Mozilla<br>Mozilla为自己的产品维护了一个公开透明的根证书库，并且大部分Linux版本都使用了Mozilla的根证书库。</p></li></ul><blockquote><p>所有的根证书库都要求CA通过专门为证书颁发机构设计的独立审计。</p></blockquote><h4 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h4><p>X.509是一种公钥基础设施的国际标准，最初是为了支持X.500而设计的。X.500是电子目录服务的标准，但未广泛使用过。X.509经过PKIX工作组改造适合在互联网上使用。</p><blockquote><p>PKIX工作组成立于1995年秋天，目标是简历支持基于X.509公钥基础设施的互联网标准。<br>PKIX工作组产出的最重要的文档是RFC5280，它描述了证书的格式、可信任证书链的建立，以及证书吊销列表(CRL)的格式。<br>PKIX在2013年10月结束了自己的使命。</p></blockquote><h4 id="CAB"><a href="#CAB" class="headerlink" title="CAB"></a>CAB</h4><p>CA/Browser论坛是由证书颁发机构、浏览器厂商以及其他有相关权益的团体自发形成的组织，目标是建立和推行证书颁发和处理的标准。</p><blockquote><p>一开始，CAB论坛是为了确定增强型证书(EV)的颁发标准而创建的，在2007年EV证书诞生了。<br>CAB最开始只是一些松散的组织，但是随后他们改变了关注焦点并且在2012年改组。<br>同年，CAB论坛发布了《公共可信证书的颁发和管理的基本要求》，即Baseline Requirements for the Issuance and Management of Publicly-Trusted Certificates, 简称Baseline Requirements</p></blockquote><h3 id="keytool"><a href="#keytool" class="headerlink" title="keytool"></a>keytool</h3><h3 id="keystore-Vs-trustsotre"><a href="#keystore-Vs-trustsotre" class="headerlink" title="keystore Vs trustsotre"></a>keystore Vs trustsotre</h3><p>KeyStore和TrustStore是JSSE中使用的两种文件。都是使用Java的keytool来管理。他们的不同主要在于用途和相应通途决定的内容的不同。<br>KeyStore用于存储自己的密码，私钥和证书。<br>TrustStore用于存储来自他人的公钥和证书。</p><h3 id="HTTPS-单向认证"><a href="#HTTPS-单向认证" class="headerlink" title="HTTPS 单向认证"></a>HTTPS 单向认证</h3><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542553793131&amp;di=4e09f8f1eacb2029a228ec7be7217ccc&amp;imgtype=0&amp;src=http%3A%2F%2Fs3.51cto.com%2Fwyfs02%2FM00%2FA5%2F15%2FwKioL1m3inPgUUgQAAFabDvTsYI063.png" alt=""></p><h3 id="HTTPS-双向认证"><a href="#HTTPS-双向认证" class="headerlink" title="HTTPS 双向认证"></a>HTTPS 双向认证</h3><p><img src="https://ask.qcloudimg.com/http-save/developer-news/9qgvflez67.jpeg" alt=""></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p>从客户端来看，SSH服务主要提供两种级别的安全验证：</p><ol><li><p>基于口令<br>只要知道服务器的SSH连接账号和口令，就能通过客户端登录到远程主机，而连接过程中所有传输的数据都是加密的。</p></li><li><p>基于密钥<br>这种方式需要先建立一个密钥对，然后把公钥放在需要访问的目标服务器上，再把私钥放到客户端或者对应的客户端服务器上。<br>如果想要连接到公用密钥的SSH服务器，客户端SSH软件或者客户端服务器就会向服务器发出请求，请求用连接的用户密钥进行安全验证。服务器收到请求后，会先寻找事先安装好的公钥，然后和客户端发送过来的密钥进行比较，如果匹配，就用公钥加密“质询”信息并发送给客户端。客户端收到“质询”信息后用私钥解密，再把它发送给服务器。<br><img src="https://github.com/Anshenzheng/ImageStore/blob/master/SSH%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86.png?raw=true" alt=""><br>执行ssh命令生成密钥对生成私钥id_rsa和公钥id_rsa.pub</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></li><li><p>应用场景</p></li></ol><ul><li>Hadoop集群间免密通讯</li><li>SFTP</li><li>Git免密提交</li></ul><h4 id="代码中使用"><a href="#代码中使用" class="headerlink" title="代码中使用"></a>代码中使用</h4><p>添加信任所有证书(不做处理)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.cert.CertificateException;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.X509TrustManager;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信任所有证书</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllTrustManager</span> <span class="keyword">implements</span> <span class="title">X509TrustManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] arg0, String arg1)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] arg0, String arg1)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用HttpsURLConnection发送POST请求（默认443端口）</p><pre><code class="Java"><span class="keyword">import</span> java.io.BufferedReader;<span class="keyword">import</span> java.io.File;<span class="keyword">import</span> java.io.FileInputStream;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.io.InputStreamReader;<span class="keyword">import</span> java.io.PrintWriter;<span class="keyword">import</span> java.net.URL;<span class="keyword">import</span> java.security.KeyManagementException;<span class="keyword">import</span> java.security.KeyStore;<span class="keyword">import</span> java.security.KeyStoreException;<span class="keyword">import</span> java.security.NoSuchAlgorithmException;<span class="keyword">import</span> java.security.SecureRandom;<span class="keyword">import</span> java.security.UnrecoverableKeyException;<span class="keyword">import</span> java.security.cert.CertificateException;<span class="keyword">import</span> javax.net.ssl.HttpsURLConnection;<span class="keyword">import</span> javax.net.ssl.KeyManagerFactory;<span class="keyword">import</span> javax.net.ssl.SSLContext;<span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;<span class="keyword">import</span> javax.net.ssl.TrustManager;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpsRequest</span> </span>{    <span class="comment">//测试url</span>    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String URL_TEST=<span class="string">"https://www.baidu.com"</span>;    <span class="comment">//客户端证书路径</span>    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PATH=<span class="string">"c://xxxx"</span>;    <span class="comment">//证书密码</span>    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String psw=<span class="string">"123456"</span>;    <span class="comment">/**</span><span class="comment">     * 发送POST请求</span><span class="comment">     * <span class="doctag">@param</span> agrs</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     * <span class="doctag">@throws</span> IOException</span><span class="comment">     * <span class="doctag">@throws</span> KeyManagementException</span><span class="comment">     * <span class="doctag">@throws</span> KeyStoreException</span><span class="comment">     * <span class="doctag">@throws</span> NoSuchAlgorithmException</span><span class="comment">     * <span class="doctag">@throws</span> CertificateException</span><span class="comment">     * <span class="doctag">@throws</span> UnrecoverableKeyException</span><span class="comment">     */</span>    <span class="function"><span class="keyword">public</span> String <span class="title">doPost</span><span class="params">(String agrs)</span> <span class="keyword">throws</span> IOException, KeyManagementException, KeyStoreException, NoSuchAlgorithmException, CertificateException, UnrecoverableKeyException</span>{        <span class="comment">//导入客户端证书</span>        KeyStore ks=KeyStore.getInstance(<span class="string">"pkcs12"</span>);        FileInputStream instream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(PATH));        ks.load(instream, psw.toCharArray());        KeyManagerFactory kmf=KeyManagerFactory.getInstance(<span class="string">"SunX509"</span>);        kmf.init(ks, psw.toCharArray());        <span class="comment">//添加信任证书</span>        TrustManager[] tm={<span class="keyword">new</span> AllTrustManager()};<span class="comment">//AllTrustManager()为信任所有证书</span>        SSLContext ctx=SSLContext.getInstance(<span class="string">"SSL"</span>);<span class="comment">//创建ssl上下文</span>        <span class="comment">//初始化 ；参数1为null，则不上传客户端证书（通常情况都是如此）；</span>        ctx.init(kmf.getKeyManagers(), tm, <span class="keyword">new</span> SecureRandom());        <span class="comment">//ctx.init(kmf.getKeyManagers(), null, new SecureRandom());//验证系统默认证书</span>        <span class="comment">//ctx.init(kmf.getKeyManagers(), TrustManager[] tm, new SecureRandom());//导出服务端证书，然后按照keymanager一样实现trustmanager</span>        SSLSocketFactory sf=ctx.getSocketFactory();        URL _url=<span class="keyword">new</span> URL(URL_TEST);        HttpsURLConnection conn=(HttpsURLConnection) _url.openConnection();        conn.setRequestMethod(<span class="string">"POST"</span>);<span class="comment">//设定请求方法</span>        conn.setConnectTimeout(<span class="number">20000</span>);        conn.setReadTimeout(<span class="number">20000</span>);        conn.setDoInput(<span class="keyword">true</span>);<span class="comment">//打开输入流</span>        conn.setDoOutput(<span class="keyword">true</span>);<span class="comment">//打开输出流写入写出参数必需</span>        conn.setSSLSocketFactory(sf);<span class="comment">//添加ssl参数</span>        <span class="comment">//输出参数</span>        PrintWriter pw=<span class="keyword">new</span> PrintWriter(conn.getOutputStream());        pw.write(agrs);        pw.flush();        <span class="comment">//获取输入流</span>        BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream()));        StringBuffer result=<span class="keyword">new</span> StringBuffer();        String s=br.readLine();        <span class="keyword">while</span>(s!=<span class="keyword">null</span>){            result.append(s);            s=br.readLine();        }        pw.close();        br.close();        <span class="keyword">return</span> result.toString();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;s
      
    
    </summary>
    
      <category term="后端" scheme="https://anshenzheng.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="keytool" scheme="https://anshenzheng.github.io/tags/keytool/"/>
    
      <category term="keystore" scheme="https://anshenzheng.github.io/tags/keystore/"/>
    
      <category term="https" scheme="https://anshenzheng.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>没有admin权限如何免安装使用Node和NPM</title>
    <link href="https://anshenzheng.github.io/2018/03/11/%E6%B2%A1%E6%9C%89admin%E6%9D%83%E9%99%90%E5%A6%82%E4%BD%95%E5%85%8D%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8Node%E5%92%8CNPM/"/>
    <id>https://anshenzheng.github.io/2018/03/11/没有admin权限如何免安装使用Node和NPM/</id>
    <published>2018-03-11T04:20:48.000Z</published>
    <updated>2018-03-11T09:30:19.660Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>此教程只针对于在windows系统上没有admin权限和软件安装权限，但是又希望能像安装版一样使用Node和NPM的用户。</p><h3 id="步骤一：-下载压缩版node"><a href="#步骤一：-下载压缩版node" class="headerlink" title="步骤一： 下载压缩版node"></a>步骤一： 下载压缩版node</h3><p>访问<a href="https://nodejs.org/en/download" target="_blank" rel="noopener">https://nodejs.org/en/download</a>, 根据自己的系统，选择下载32位或者64位的免安装压缩包版node。<br>解压压缩包，将node.exe文件拷贝到自己想要存放node的路径，比如C:\annan\nodejs\。</p><h3 id="步骤二：-下载压缩版NPM"><a href="#步骤二：-下载压缩版NPM" class="headerlink" title="步骤二： 下载压缩版NPM"></a>步骤二： 下载压缩版NPM</h3><p>访问<a href="https://github.com/npm/npm/releases" target="_blank" rel="noopener">https://github.com/npm/npm/releases</a>, 下载最新发布的稳定版NPM。<br>解压压缩包，并将解压出的主文件目录更名为npm.<br>打开步骤一中存放node.exe的文件目录, 新建文件夹命名为node_modules, 之后将整个npm文件夹拷贝到node_modules文件夹中。</p><h3 id="步骤三：-拷贝npm-cmd文件到node-exe所在目录"><a href="#步骤三：-拷贝npm-cmd文件到node-exe所在目录" class="headerlink" title="步骤三： 拷贝npm.cmd文件到node.exe所在目录"></a>步骤三： 拷贝npm.cmd文件到node.exe所在目录</h3><p>打开步骤二中node_modules\npm\bin目录，找到npm.cmd文件， 并将之拷贝到node.exe文件所在的目录。</p><h3 id="步骤四：-配置环境变量"><a href="#步骤四：-配置环境变量" class="headerlink" title="步骤四： 配置环境变量"></a>步骤四： 配置环境变量</h3><p>打开cmd命令行工具， 执行指令“rundll32 sysdm.cpl,EditEnvironmentVariables”之后，环境变量面板会自动跳出，之后将node.exe和npm.cmd所在路径配置到环境变量path中，这样我们就可以随意使用node和npm命令了。</p><h3 id="步骤五：-验证设置"><a href="#步骤五：-验证设置" class="headerlink" title="步骤五： 验证设置"></a>步骤五： 验证设置</h3><p>打开命令行工具， 输入node -v 之后输入npm -v，就可以看到我们已经配置安装好了最新版本的node和npm.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\annan&gt;node -v</span><br><span class="line">v8.10.0</span><br><span class="line"></span><br><span class="line">C:\Users\annan&gt;npm -v</span><br><span class="line">5.7.1</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;此教程只针对于在windows系统上没有admin权限和软件安装权限，但是又希望能像安装版一样使用Node和NPM的用户。&lt;/p&gt;
&lt;h3 id=&quot;步骤一：-下载压缩版nod
      
    
    </summary>
    
      <category term="前端" scheme="https://anshenzheng.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://anshenzheng.github.io/tags/node/"/>
    
      <category term="NPM" scheme="https://anshenzheng.github.io/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>Angular</title>
    <link href="https://anshenzheng.github.io/2018/01/20/Angular/"/>
    <id>https://anshenzheng.github.io/2018/01/20/Angular/</id>
    <published>2018-01-20T11:45:57.000Z</published>
    <updated>2018-01-20T13:18:24.616Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Angular 是由Google开发与维护的一个开发跨平台应用程序的框架，适用于手机与桌面，是一个比较完善的前端MVC框架，包含了模版，双向数据绑定，路由，服务，过滤器，依赖注入等功能。</p><h3 id="Angular提供的功能"><a href="#Angular提供的功能" class="headerlink" title="Angular提供的功能"></a>Angular提供的功能</h3><ul><li>动态HTML</li><li>强大的表单系统</li><li>强大的视图引擎</li><li>快速的页面渲染</li><li>灵活的路由</li><li>HTTP服务</li><li>视图封装</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="1-基于Angular-Quickstart"><a href="#1-基于Angular-Quickstart" class="headerlink" title="1. 基于Angular Quickstart"></a>1. 基于Angular Quickstart</h4><p>1.1 克隆官方标准项目<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/angular/quickstart ng4-quickstart</span><br></pre></td></tr></table></figure></p><p>1.2 安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ng4-quickstart</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure></p><p>1.3 启动应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure></p><h4 id="2-基于Angular-CLI"><a href="#2-基于Angular-CLI" class="headerlink" title="2. 基于Angular CLI"></a>2. 基于Angular CLI</h4><p>1.1 安装Angular CLI<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @angular/cli</span><br></pre></td></tr></table></figure></p><p>1.2 检测是否安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng --version</span><br></pre></td></tr></table></figure></p><p>1.3 创建新项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng new PROJECT-NAME</span><br></pre></td></tr></table></figure></p><blockquote><p>若在后面添加参数 –routing, 则会在app目录中创建对应的路由相关配置文件。</p></blockquote><p>1.4 启动本地服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd PROJECT-NAME</span><br><span class="line">ng serve</span><br></pre></td></tr></table></figure></p><blockquote><p>ng server命令会启动开发服务器，监听文件的变化，文件修改后会自动重新构建应用。 Welcome to app如下图：</p></blockquote><p><img src="https://www.angular.cn/generated/images/guide/cli-quickstart/app-works.png" alt=""><br>1.5 Angular启动过程<br>功过项目根目录下的angular-cli.json文件，可以发现启动js文件位于src/main.ts中，页面的入口文件位于src/index.html.</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><img src="https://img.mukewang.com/5a5435fe00011c5019201080.jpg" alt=""><br>核心概念总览<br><img src="https://img.mukewang.com/5a4e486f0001f81a19201080.jpg" alt=""></p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p><img src="https://img.mukewang.com/5a4183e200014abd19201080.jpg" alt=""><br><img src="https://img.mukewang.com/5a4183f70001850e19201080.jpg" alt=""><br><img src="https://img.mukewang.com/5a4e48270001237119201080.jpg" alt=""><br><img src="https://img.mukewang.com/5a4e471100015a0e19201080.jpg" alt=""></p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><img src="https://img.mukewang.com/59d0be37000119d019201080.jpg" alt=""></p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p><img src="https://img.mukewang.com/5a4e3e370001e11619201080.jpg" alt=""></p><h4 id="Angular-路由"><a href="#Angular-路由" class="headerlink" title="Angular 路由"></a>Angular 路由</h4><p>路由是Angular导航的关键。<br>在设置路由之前，我们需要在app/index.html中添加路由说明<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>路由模块已经从Angular中分离出来，所以使用时需要导入：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; RouterModule, Routes&#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br></pre></td></tr></table></figure></p><p>现在写一个简单的路由配置：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/modules/app-routing.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;NgModule&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Routes, RouterModule&#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;DemoComponentComponent&#125; <span class="keyword">from</span> <span class="string">'../demo/demo-component/demo-component.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">&#123;</span><br><span class="line">path: <span class="string">'demoComponent'</span>, component: DemoComponentComponent</span><br><span class="line">&#125;,...,</span><br><span class="line">&#123;</span><br><span class="line">path: <span class="string">'**'</span>, component: DemoComponentComponent</span><br><span class="line">&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">imports: [RouterModule.forRoot(routes)],</span><br><span class="line">exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppRoutingModule&#123;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>**为通配<br>path 不能以”/“开头<br>在特性模块中，应使用RouterModule.forChild</p></blockquote><p>定义好路由模块，还需将其注册到主模块中：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;AppComponent&#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;AppRoutingModule&#125; <span class="keyword">from</span> <span class="string">'./modules/app-routing.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">...,</span><br><span class="line">imports:[..., AppRoutingModule],</span><br><span class="line">providers:[],</span><br><span class="line">bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>有了路由导航之后， 还需要一个容器来显示对应的组件内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="Angular-依赖注入"><a href="#Angular-依赖注入" class="headerlink" title="Angular 依赖注入"></a>Angular 依赖注入</h4><h5 id="组件中注入服务："><a href="#组件中注入服务：" class="headerlink" title="组件中注入服务："></a>组件中注入服务：</h5><p>配置已创建的服务<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  providers: [MemberService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>导入已创建的服务<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; MemberService &#125; <span class="keyword">from</span> <span class="string">'../member.service'</span>;</span><br></pre></td></tr></table></figure></p><p>使用构造方式注入服务<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MembersComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> memberService: MemberService</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="服务使用示例"><a href="#服务使用示例" class="headerlink" title="服务使用示例"></a>服务使用示例</h5><p>创建服务</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Http &#125; <span class="keyword">from</span> <span class="string">'@angular/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MemberService &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: Http</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    getMembers() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.http</span><br><span class="line">            .get(<span class="string">`https://api.github.com/orgs/angular/members?page=1&amp;per_page=5`</span>)</span><br><span class="line">            .map(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置服务<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; MemberService &#125; <span class="keyword">from</span> <span class="string">"./member.service"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  providers:[MemberService],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>使用服务<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> &#123; MemberService &#125; <span class="keyword">from</span> <span class="string">"./member.service"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;...&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MembersComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">    members: Member[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> memberService: MemberService</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">ngOnInit() &#123;</span><br><span class="line">        <span class="keyword">this</span>.memberService.getMembers()</span><br><span class="line">            .subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (data) <span class="keyword">this</span>.members = data;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><h5 id="应用示例-1"><a href="#应用示例-1" class="headerlink" title="应用示例 1"></a>应用示例 1</h5><p><img src="https://coding.imooc.com/static/module/class/content/img/94/2.png" alt=""></p><h5 id="应用示例-2"><a href="#应用示例-2" class="headerlink" title="应用示例 2"></a>应用示例 2</h5><p><img src="https://img.mukewang.com/59b69bd20001f1e319201080.jpg" alt=""></p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p><img src="https://img.mukewang.com/5a40958700017f9b19201080.jpg" alt=""><br><img src="https://img.mukewang.com/5a3f47c700019cb219201080.jpg" alt=""></p><h5 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h5><p><img src="https://img.mukewang.com/5a3f4b320001ec6319201080.jpg" alt=""><br><img src="https://img.mukewang.com/5a350fbe0001a00419201080.jpg" alt=""></p><h5 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h5><p><img src="https://img.mukewang.com/5a3f471900010fc719201080.jpg" alt=""></p><h4 id="数据绑定，-响应式编程和管道"><a href="#数据绑定，-响应式编程和管道" class="headerlink" title="数据绑定， 响应式编程和管道"></a>数据绑定， 响应式编程和管道</h4><p><img src="https://img.mukewang.com/5a3f4a060001c32f19201080.jpg" alt=""></p><h4 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h4><p>Angular中有两种表单<br>Template Driven Forms: 模版驱动表单<br>Reactive Forms: 响应式表单</p><h5 id="模板驱动表单"><a href="#模板驱动表单" class="headerlink" title="模板驱动表单"></a>模板驱动表单</h5><p>导入表单模块<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;FormsModule&#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">imports: [BrowserModule, FormsModule],</span><br><span class="line">declarations: [AppComponent, UserComponent],</span><br><span class="line">bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>表单使用示例<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">selector: <span class="string">'sl-user'</span>,</span><br><span class="line">template:<span class="string">'</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&lt;div *ngIf=showSkills&gt;</span></span><br><span class="line"><span class="string">&lt;h3&gt;My Skills&lt;/h3&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&lt;form (submit)="addSkill(skill.value)"&gt;</span></span><br><span class="line"><span class="string">&lt;label&gt;Add new Skills&lt;/label&gt;</span></span><br><span class="line"><span class="string">&lt;input type="text" #skill&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UserComponent&#123;</span><br><span class="line">addSkill(skill: <span class="built_in">string</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> skillStr = skill.trim();</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.skills.indexOf(skillStr) === <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>.skills.push(skillStr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="与服务端通讯"><a href="#与服务端通讯" class="headerlink" title="与服务端通讯"></a>与服务端通讯</h4><p>使用http协议和WebSocket协议与服务器进行通讯。</p><h5 id="导入入Http模块"><a href="#导入入Http模块" class="headerlink" title="导入入Http模块"></a>导入入Http模块</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;HttpModule&#125; <span class="keyword">from</span> <span class="string">'@angular/http'</span>;</span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">imports: [BrowserModule, FormsModule, HttpModule],</span><br><span class="line">declarations: [AppComponent, UserComponent],</span><br><span class="line">bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule</span><br></pre></td></tr></table></figure><p>使用Http服务步骤</p><ol><li>从@angular/http模块中导入Http类</li><li>使用DI注入http服务</li><li>调用http的get()/post()等方法设置请求地址并发送HTTP请求</li><li>调用Response对象的json()方法，将response转换为JSON对象</li><li>把请求结果赋值给对应的属性<h5 id="Http服务使用示例"><a href="#Http服务使用示例" class="headerlink" title="Http服务使用示例"></a>Http服务使用示例</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Http &#125; <span class="keyword">from</span> <span class="string">'@angular/http'</span>; <span class="comment">// (1)</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'rxjs/add/operator/map'</span>; <span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Member &#123;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    login: <span class="built_in">string</span>;</span><br><span class="line">    avatar_url: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'sl-members'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h3&gt;Angular Orgs Members&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;ul *ngIf="members"&gt;</span></span><br><span class="line"><span class="string">      &lt;li *ngFor="let member of members;"&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;</span></span><br><span class="line"><span class="string">          &lt;img [src]="member.avatar_url" width="48" height="48"/&gt;</span></span><br><span class="line"><span class="string">          ID：&lt;span&gt;&#123;&#123;member.id&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">          Name: &lt;span&gt;&#123;&#123;member.login&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MembersComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">  members: Member[];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: Http</span>) &#123; &#125; <span class="comment">// (3)</span></span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.http.get(<span class="string">`https://api.github.com/orgs/angular/members?page=1&amp;per_page=5`</span>) <span class="comment">// (4)</span></span><br><span class="line">        .map(<span class="function"><span class="params">res</span> =&gt;</span> res.json()) <span class="comment">// (5)</span></span><br><span class="line">        .subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (data) <span class="keyword">this</span>.members = data; <span class="comment">// (6)</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h4><ul><li>ngIf</li><li>ngModel</li></ul><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Directive, ElementRef, Renderer&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Directive</span>(&#123;</span><br><span class="line">selector: <span class="string">'[highlight]'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HighlightDirective&#123;</span><br><span class="line"><span class="keyword">constructor</span>(<span class="params">el: ElementRef, render: Renderer</span>)&#123;</span><br><span class="line">render.setElementStyle(el.nativeElement, <span class="string">'backgroundColor'</span>, <span class="string">'yellow'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构建和部署"><a href="#构建和部署" class="headerlink" title="构建和部署"></a>构建和部署</h4><p>编译Typescript写成的项目，将其构建为最终可发布的js代码，并发布到nodejs服务器上去。</p><h4 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h4><p>AppModule<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HttpModule &#125; <span class="keyword">from</span> <span class="string">'@angular/http'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RouterModule, Routes &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserComponent &#125; <span class="keyword">from</span> <span class="string">'./user.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MembersComponent &#125; <span class="keyword">from</span> <span class="string">'./members.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MemberService &#125; <span class="keyword">from</span> <span class="string">"./member.service"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ROUTES: Routes = [</span><br><span class="line">  &#123; path: <span class="string">''</span>, pathMatch: <span class="string">'full'</span>, redirectTo: <span class="string">'user'</span> &#125;,</span><br><span class="line">  &#123; path: <span class="string">'user'</span>, component: UserComponent &#125;,</span><br><span class="line">  &#123; path: <span class="string">'members'</span>, component: MembersComponent &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [BrowserModule, FormsModule, HttpModule,</span><br><span class="line">    RouterModule.forRoot(ROUTES)],</span><br><span class="line">  declarations: [AppComponent, UserComponent, MembersComponent],</span><br><span class="line">  providers: [MemberService],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>AppComponent<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'my-app'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="app"&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;欢迎来到Angular的世界&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      &lt;nav&gt;</span></span><br><span class="line"><span class="string">        &lt;a routerLink="/user"&gt;我的&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;a routerLink="/members"&gt;Angular成员&lt;/a&gt;</span></span><br><span class="line"><span class="string">      &lt;/nav&gt;</span></span><br><span class="line"><span class="string">      &lt;router-outlet&gt;&lt;/router-outlet&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>UserComponent<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Address &#123;</span><br><span class="line">    province: <span class="built_in">string</span>;</span><br><span class="line">    city: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'sl-user'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h2&gt;大家好，我是&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;我来自&lt;strong&gt;&#123;&#123;address.province&#125;&#125;&lt;/strong&gt;省,</span></span><br><span class="line"><span class="string">      &lt;strong&gt;&#123;&#123;address.city&#125;&#125;&lt;/strong&gt;市</span></span><br><span class="line"><span class="string">    &lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;button (click)="toggleSkills()"&gt;</span></span><br><span class="line"><span class="string">        &#123;&#123; showSkills ? "隐藏技能" : "显示技能" &#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;div *ngIf="showSkills"&gt;</span></span><br><span class="line"><span class="string">        &lt;h3&gt;我的技能&lt;/h3&gt;</span></span><br><span class="line"><span class="string">        &lt;ul&gt;</span></span><br><span class="line"><span class="string">            &lt;li *ngFor="let skill of skills"&gt;</span></span><br><span class="line"><span class="string">                &#123;&#123;skill&#125;&#125;</span></span><br><span class="line"><span class="string">            &lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &lt;form (submit)="addSkill(skill.value)"&gt;</span></span><br><span class="line"><span class="string">            &lt;label&gt;添加技能&lt;/label&gt;</span></span><br><span class="line"><span class="string">            &lt;input type="text" #skill&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> UserComponent &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    address: Address;</span><br><span class="line">    showSkills: <span class="built_in">boolean</span>;</span><br><span class="line">    skills: <span class="built_in">string</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'Semlinker'</span>;</span><br><span class="line">        <span class="keyword">this</span>.address = &#123;</span><br><span class="line">            province: <span class="string">'福建'</span>,</span><br><span class="line">            city: <span class="string">'厦门'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.showSkills = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.skills = [<span class="string">'AngularJS 1.x'</span>, <span class="string">'Angular 2.x'</span>, <span class="string">'Angular 4.x'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toggleSkills() &#123;</span><br><span class="line">        <span class="keyword">this</span>.showSkills = !<span class="keyword">this</span>.showSkills;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addSkill(skill: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> skillStr = skill.trim();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.skills.indexOf(skillStr) === <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.skills.push(skillStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MembersComponent<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, OnInit &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Http &#125; <span class="keyword">from</span> <span class="string">'@angular/http'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'rxjs/add/operator/map'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; MemberService &#125; <span class="keyword">from</span> <span class="string">"./member.service"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Member &#123;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    login: <span class="built_in">string</span>;</span><br><span class="line">    avatar_url: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'sl-members'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h3&gt;Angular Orgs Members&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;ul *ngIf="members"&gt;</span></span><br><span class="line"><span class="string">      &lt;li *ngFor="let member of members;"&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;</span></span><br><span class="line"><span class="string">          &lt;img [src]="member.avatar_url" width="48" height="48"/&gt;</span></span><br><span class="line"><span class="string">          ID：&lt;span&gt;&#123;&#123;member.id&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">          Name: &lt;span&gt;&#123;&#123;member.login&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MembersComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">    members: Member[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> memberService: MemberService</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        <span class="keyword">this</span>.memberService.getMembers()</span><br><span class="line">            .subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (data) <span class="keyword">this</span>.members = data;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MemberService<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Http &#125; <span class="keyword">from</span> <span class="string">'@angular/http'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MemberService &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> http: Http</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    getMembers() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.http</span><br><span class="line">            .get(<span class="string">`https://api.github.com/orgs/angular/members?page=1&amp;per_page=5`</span>)</span><br><span class="line">            .map(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Angular 是由Google开发与维
      
    
    </summary>
    
      <category term="前端" scheme="https://anshenzheng.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Angular" scheme="https://anshenzheng.github.io/tags/Angular/"/>
    
      <category term="前端" scheme="https://anshenzheng.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="“框架”" scheme="https://anshenzheng.github.io/tags/%E2%80%9C%E6%A1%86%E6%9E%B6%E2%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>IBM UrbanCode Deploy</title>
    <link href="https://anshenzheng.github.io/2017/09/29/IBM-UrbanCode-Deploy/"/>
    <id>https://anshenzheng.github.io/2017/09/29/IBM-UrbanCode-Deploy/</id>
    <published>2017-09-29T15:19:03.000Z</published>
    <updated>2017-09-30T01:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="企业应用部署面临的挑战分析述"><a href="#企业应用部署面临的挑战分析述" class="headerlink" title="企业应用部署面临的挑战分析述"></a>企业应用部署面临的挑战分析述</h1><p>企业应用(Enterprise Application)是指运行在操作系统和中间件之上，实现特定业务逻辑的软件发布包和业务数据。企业应用部署(Enterprise Application Deployment)是把企业应用部署在一台或多台计算机的操作系统或中间件之上，从而提供一个可供测试、培训和生产的运行环境。</p><p>企业应用部署是软件持续交付（Continuous Delivery）的重要环节，特别是所交付的企业应用部署架构复杂（比如多机）、部署环境多（比如开发、测试、生产环境）和部署频率高（比如每周一次）时，如何提高企业应用部署的效率和质量，对企业信息化是否能快速满足业务需求的快速变化至关重要。</p><p>然而，当前的企业应用部署在方法体系上缺乏完善的管理信息模型，在工具上采用手工编写和执行部署脚本。这种传统的应用部署方式会导致部署效率不高，对部署过程缺乏管控，对部署结果缺乏审计。</p><h1 id="IBM-UrbanCode-Deploy-概述"><a href="#IBM-UrbanCode-Deploy-概述" class="headerlink" title="IBM UrbanCode Deploy 概述"></a>IBM UrbanCode Deploy 概述</h1><p>IBM UrbanCode Deploy（简称 UCD）是 IBM 的应用自动化部署工具。该工具基于一个完善的应用部署自动化管理信息模型，提供可视化的部署逻辑设计手段，并通过远程代理技术，实现对复杂应用在不同环境下的自动化部署。该工具功能组件参考下图：</p><blockquote><p>图 1. IBM UCD 功能组件图</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image003.jpg" alt=""><br>UCD 不仅仅是一个实现应用部署自动化的工具，还是一个服务于系统工程师（负责部署环境的系统管理）、发布工程师（负责应用的部署逻辑设计）、部署工程师（负责执行应用部署）和质量工程师（负责应用部署前和部署后的质量审计）等多个角色的管理平台。</p><p>该平台所提供的功能点包括如下：<br>1、环境管理：实现对被部署机器以及所提供资源（比如数据库、中间件等）的管理。<br>2、组件管理：实现对应用部署组件（比如企业应用的安装包、数据更新脚本等）的维护，以及组件部署逻辑（比如如何安装在 Tomcat 上安装一个发布包）的可视化设计。<br>3、应用管理：实现企业应用的维护、关联组件以及如何编排多个组件的部署逻辑来完成整个应用的部署逻辑。<br>4、执行管理：实现应用部署环境的定义、资源的映射以及应用部署的执行。<br>5、仪表盘：实现对应用部署的统计分析，包括成功、失败统计分析以及部署时长统计分析等。<br>6、部署工件管理：实现对部署文件的集中存储，版本比对等功能。<br>7、插件管理：实现对可重用部署步骤的管理，并可自定义可重用的部署步骤。<br>8、系统管理：实现用户、组、角色、团队的管理，定义完善的权限策略。</p><h1 id="IBM-UrbanCode-Deploy-系统架构"><a href="#IBM-UrbanCode-Deploy-系统架构" class="headerlink" title="IBM UrbanCode Deploy 系统架构"></a>IBM UrbanCode Deploy 系统架构</h1><p>作为一个企业应用部署自动化管理平台，UCD 基于如下逻辑技术架构，确保支持复杂环境（比如有部署环境和服务器之间有防火墙）下的应用部署。下面将分别介绍 UCD 的每个技术组件。</p><blockquote><p>图 2. IBM UCD 系统架构图</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image005.gif" alt=""></p><h4 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a>应用服务器</h4><p>基于 Tomcat 的 JavaEE 应用，是 UCD 的核心并提供主要的功能。</p><h4 id="CodeStation"><a href="#CodeStation" class="headerlink" title="CodeStation"></a>CodeStation</h4><p>UCD 自带的发布文件存储库，提供发布文件的版本管理功能。</p><h4 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h4><p>存储 UCD 的管理信息，比如用户信息、部署逻辑信息等。</p><h4 id="Browser（浏览器）"><a href="#Browser（浏览器）" class="headerlink" title="Browser（浏览器）"></a>Browser（浏览器）</h4><p>UCD 用户的主要使用界面，提供应用部署自动化的日常管理界面。</p><h4 id="Client（客户端）"><a href="#Client（客户端）" class="headerlink" title="Client（客户端）"></a>Client（客户端）</h4><p>UCD 提供的命令行，用户可通过命令行来访问 UCD。</p><h4 id="Agent（代理）"><a href="#Agent（代理）" class="headerlink" title="Agent（代理）"></a>Agent（代理）</h4><p>安装在被部署机器上，提供远程执行部署逻辑的能力。</p><h4 id="中继服务器（Relay-Server）"><a href="#中继服务器（Relay-Server）" class="headerlink" title="中继服务器（Relay Server）"></a>中继服务器（Relay Server）</h4><p>当被部署的环境和 UCD 应用服务器之间有防火墙时，中继服务器作为一个中转实现代理和应用服务器之间的通信。</p><h1 id="IBM-UrbanCode-Deploy-信息模型"><a href="#IBM-UrbanCode-Deploy-信息模型" class="headerlink" title="IBM UrbanCode Deploy 信息模型"></a>IBM UrbanCode Deploy 信息模型</h1><p>为了实现对多应用、多环境的自动化部署，UCD 定义了完善的信息模型。信息模型就是描述了特定领域的信息类型以及相互关系，是对某个特定领域的抽象，也是开发特定领域软件工具的基础。下图是 UCD 所包含的应用部署自动化管理信息模型。</p><blockquote><p>图 3. IBM UCD 信息模型</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image007.jpg" alt=""><br>本文将以 JPetStore 应用为例解释上图的信息模型。JPetStore 是一个基于 Struts 和 iBATIS 技术的网上宠物店应用，该应用的中间件采用 Tomcat，数据库采用 MySQL。</p><p>在上图中，<img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image009.jpg" alt="">表示 A 和 B 之间是包含关系，也就是说如果 A 类型实例不存在，那 A 类型实例所包含的 B 类型实例也不会存在，”*”表示一个 A 类型实例可包含 0 个或多个 B 类型实例。<br><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image011.jpg" alt="">表示 C 和 D 是关联关系，也是说一个 C 类型实例可以关联 0 个或多个 D 类型实例。</p><h4 id="应用（Application）"><a href="#应用（Application）" class="headerlink" title="应用（Application）"></a>应用（Application）</h4><p>针对特定用户，并解决特定业务问题的软件包和数据，比如 JPetStore 就是一个应用。</p><h4 id="组件（Component）"><a href="#组件（Component）" class="headerlink" title="组件（Component）"></a>组件（Component）</h4><p>具有独立功能，并可被复用的一组文件。比如 JPetStore 应用中，可涉及实现网上宠物店应用逻辑的 JPetStore_APP 组件、提供宠物照片的 JPetStore_WEB 组件以及定义数据库的 JPetStore_DB 组件。</p><h4 id="版本（Version）"><a href="#版本（Version）" class="headerlink" title="版本（Version）"></a>版本（Version）</h4><p>一个组件所包含的部署文件的多个版本。比如 JPetStore_APP 组件的 JPetStore.war 文件可以有 1.0，1.1 等多个版本。</p><h4 id="版本状态（Version-Status）"><a href="#版本状态（Version-Status）" class="headerlink" title="版本状态（Version Status）"></a>版本状态（Version Status）</h4><p>组件版本所对应的质量状态。比如 JPetStore_APP 的 1.1 版本已经通过系统集成测试，则该组件版本的状态可设置为“已通过系统集成测试”。</p><h4 id="快照（Snapshot）"><a href="#快照（Snapshot）" class="headerlink" title="快照（Snapshot）"></a>快照（Snapshot）</h4><p>一个应用的特定版本，该应用版本关联一组组件版本。比如 JPetStore 应用的 1.1 版本关联了 JPetStore_APP 组件的 1.1 版本、JPetStore_WEB 组件的 1.0 版本以及 JPetStore_DB 组件的 1.0 版本。<br>步骤（Step）：可重用的特定部署任务，比如在把 JPetStore_APP 组件部署到 Tomcat 应用时，“启动 Tomcat 服务器”就是一个步骤。</p><h4 id="插件（-Plugin）"><a href="#插件（-Plugin）" class="headerlink" title="插件（ Plugin）"></a>插件（ Plugin）</h4><p>包含一组相关步骤的容器。比如针对 Tomcat 应用的部署，常用的步骤包括“启动 Tomcat 服务器”、“卸载 WAR 包”、“安装 WAR 包”等。这些步骤放在“Tomcat”这个插件容器中。</p><h4 id="组件流程（Component-Process）"><a href="#组件流程（Component-Process）" class="headerlink" title="组件流程（Component Process）"></a>组件流程（Component Process）</h4><p>针对特定组件所定义的操作步骤序列，该操作步骤序列引用 Plugin 中定义的步骤。比如针对 JPetStore_APP 组件，可定义安装该组件的“Install APP”流程、卸载该组件的“Uninstall APP”流程。</p><h4 id="应用流程（Application-Process）"><a href="#应用流程（Application-Process）" class="headerlink" title="应用流程（Application Process）"></a>应用流程（Application Process）</h4><p>对一个完整应用所定义的操作步骤，比如为部署 JPetStore 应用所定义的应用部署流程“Install Process”，该流程引用了 JPetStore_APP 组件流程“Install APP ”、JPetStore_DB 组件流程“Install DB”和 JPetStore_WEB 组件流程“Install WEB ”。</p><h4 id="代理（Agent）"><a href="#代理（Agent）" class="headerlink" title="代理（Agent）"></a>代理（Agent）</h4><p>部署在一台计算机上的进程，该进程实现部署逻辑在该计算机上的执行。比如 JPetStore 将在两台计算机上部署，则定义的 agent 是“agent101”和“agent102”。</p><h4 id="代理池（Agent-Pool）"><a href="#代理池（Agent-Pool）" class="headerlink" title="代理池（Agent Pool）"></a>代理池（Agent Pool）</h4><p>对代理按特定分类标准而进行的分类，比如按代理的用途分可创建“测试服务器”和“生产服务器”代理池，按操作系统类型分可创建“Windows 服务器”和“LINUX 服务器”。一个代理池可关联多个代理，而一个代理也可以被多个代理池关联。</p><h4 id="资源（Resource）"><a href="#资源（Resource）" class="headerlink" title="资源（Resource）"></a>资源（Resource）</h4><p>在特定代理机上所提供的能力，比如 Tomcat 服务资源，数据库资源，一个代理可包含多个资源。</p><h4 id="环境（Environment）"><a href="#环境（Environment）" class="headerlink" title="环境（Environment）"></a>环境（Environment）</h4><p>针对特定应用以及特定用途所映射的一组资源。比如针对 JPetStore 应用可定义集成测试环境 SIT（System Integration Test）和用户验收测试环境 UAT（User Acceptance Test）。</p><h4 id="审批流程（Approval-Process）"><a href="#审批流程（Approval-Process）" class="headerlink" title="审批流程（Approval Process）"></a>审批流程（Approval Process）</h4><p>针对特定环境所定义的审批流程，比如把应用部署到 UAT 环境时，需要通过质量保证工程师的审批，则可定义一个审批流程。</p><h4 id="环境门（Environment-Gate）"><a href="#环境门（Environment-Gate）" class="headerlink" title="环境门（Environment Gate）"></a>环境门（Environment Gate）</h4><p>是指应用在特定环境部署时所需要部署的组件版本必须要满足的条件。比如当应用要部署到 UAT 环境时，所部署的组件版本必须处于“已通过系统集成测试”状态。<br>此外，UCD 作为一个企业级应用部署自动化平台，有不同用户访问该工具，因此需要定义完善的权限管理模型。下图是 UCD 是提供的权限信息模型。</p><blockquote><p>图 4. IBM UCD 权限信息模型</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image013.jpg" alt=""></p><h4 id="用户（User）"><a href="#用户（User）" class="headerlink" title="用户（User）"></a>用户（User）</h4><p>访问 UCD 的一个注册用户。</p><h4 id="角色（Role）"><a href="#角色（Role）" class="headerlink" title="角色（Role）"></a>角色（Role）</h4><p>具有一组特定权限的用户类型。比如针对 JPetStore 应用的部署管理，可定义“系统工程师”、“发布工程师”、“部署工程师”和“质量工程师”等角色。</p><h4 id="团队（Team）"><a href="#团队（Team）" class="headerlink" title="团队（Team）"></a>团队（Team）</h4><p>是对 UCD 中所定义的应用部署对象（比如应用、组件等）进行的分类，比如为了确保只有特定人员能访问 JPetStore 应用相关的信息，可创建 JPetStore 团队，然后分配该团队中不同角色所对应的用户。</p><h4 id="许可（Permission）"><a href="#许可（Permission）" class="headerlink" title="许可（Permission）"></a>许可（Permission）</h4><p>是指能进行特定操作的能力，比如“创建资源”就是一个许可。</p><h4 id="安全类型（Security-Type）"><a href="#安全类型（Security-Type）" class="headerlink" title="安全类型（Security Type）"></a>安全类型（Security Type）</h4><p>一组相关的许可。</p><h4 id="组（Group）"><a href="#组（Group）" class="headerlink" title="组（Group）"></a>组（Group）</h4><p>一组相关的用户，便于快速分配特定角色所对应的用户。</p><h1 id="IBM-应用部署自动化工具-UrbanCode-Deploy-使用模型"><a href="#IBM-应用部署自动化工具-UrbanCode-Deploy-使用模型" class="headerlink" title="IBM 应用部署自动化工具 UrbanCode Deploy 使用模型"></a>IBM 应用部署自动化工具 UrbanCode Deploy 使用模型</h1><p>UCD 提供了丰富的应用部署管理功能，不同的用户可以通过浏览器页面完成与应用部署相关的工作。下面以 JPetStore 应用为例，介绍如何利用 UCD 把 JPetStore 应用自动部署到系统集成测试环境（SIT）和用户验收测试环境（UAT）的流程。</p><h2 id="JPetStore-应用部署准备流程"><a href="#JPetStore-应用部署准备流程" class="headerlink" title="JPetStore 应用部署准备流程"></a>JPetStore 应用部署准备流程</h2><h3 id="定义-JPetStore-应用部署资源"><a href="#定义-JPetStore-应用部署资源" class="headerlink" title="定义 JPetStore 应用部署资源"></a>定义 JPetStore 应用部署资源</h3><p>系统工程师通过 UCD 建立代理以及资源。在应用比较多、资源比较复杂时，建议按应用、环境、代理、资源对资源进行层次组织。如下图定义了 JPetStore 应用所对应的资源。</p><blockquote><p>图 5. 定义应用部署资源</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image015.jpg" alt=""></p><h3 id="定义-JPetStore-应用和组件"><a href="#定义-JPetStore-应用和组件" class="headerlink" title="定义 JPetStore 应用和组件"></a>定义 JPetStore 应用和组件</h3><p>发布工程师通过 UCD 建立应用以及组件，并定义组件流程和应用流程。下图是针对 JPetStore 应用的 JPetStore_APP 组件所定义的组件流程。UCD 提供了丰富的 Plugin，利用 Plugin 中包含的步骤可通过可视化方式快速定义部署逻辑。</p><blockquote><p>图 6. 定义组件部署流程</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image017.jpg" alt=""></p><h3 id="定义-JPetStore-部署组件和资源的映射"><a href="#定义-JPetStore-部署组件和资源的映射" class="headerlink" title="定义 JPetStore 部署组件和资源的映射"></a>定义 JPetStore 部署组件和资源的映射</h3><p>在执行应用部署前，应用发布工程师需要确定在不同的环境下每个组件所对应的资源。比如在下图中，JPetStore 在部署到 SIT 环境时，将把 JPetStore_APP、JPetStore_DB 和 JPetStore_WEB 组件都部署到 Agent101 提供的资源上。</p><blockquote><p>图 7. 定义部署组件和资源的映射</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image019.jpg" alt=""></p><h2 id="JPetStore-应用部署执行流程"><a href="#JPetStore-应用部署执行流程" class="headerlink" title="JPetStore 应用部署执行流程"></a>JPetStore 应用部署执行流程</h2><p>该流程完成把 JPetStore_APP 组件的一个新版本部署到 SIT 环境和 UAT 环境的流程。</p><h3 id="导入-JPetStore-APP-组件的新版本"><a href="#导入-JPetStore-APP-组件的新版本" class="headerlink" title="导入 JPetStore_APP 组件的新版本"></a>导入 JPetStore_APP 组件的新版本</h3><p>应用发布工程师在获知有新的组件版本时，执行版本导入（Import Versions）操作，把最新的组件版本导入到 UCD 中。下图是把JPetStore_APP 组件的 1.3 版本导入到 UCD 中，并可比较不同版本之间的差异。</p><blockquote><p>图 8. 导入组件的新版本</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image021.jpg" alt=""></p><h3 id="执行-JPetStore-应用在-SIT-环境上的部署"><a href="#执行-JPetStore-应用在-SIT-环境上的部署" class="headerlink" title="执行 JPetStore 应用在 SIT 环境上的部署"></a>执行 JPetStore 应用在 SIT 环境上的部署</h3><p>部署工程师选定 JPetStore 应用，执行在 SIT 环境上部署，并选择部署组件的最新版本。如下图：</p><blockquote><p>图 9. 执行应用部署</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image023.jpg" alt=""></p><h3 id="查看-JPetStore-应用在-SIT-环境上部署的组件版本"><a href="#查看-JPetStore-应用在-SIT-环境上部署的组件版本" class="headerlink" title="查看 JPetStore 应用在 SIT 环境上部署的组件版本"></a>查看 JPetStore 应用在 SIT 环境上部署的组件版本</h3><p>在完成部署后，部署工程师可获得在 SIT 环境上所部署的版本，以及通过“View Request”查看详尽的部署日志。</p><blockquote><p>图 10. 查看部署结果</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image025.jpg" alt=""></p><h3 id="创建-JPetStore-应用的快照"><a href="#创建-JPetStore-应用的快照" class="headerlink" title="创建 JPetStore 应用的快照"></a>创建 JPetStore 应用的快照</h3><p>为了能快速把已经成功部署到 SIT 环境的应用版本部署到其它环境上或者实现应用部署活动的回退，可创建一个应用的快照。下图是基于 SIT 环境上部署的版本创建一个应用快照“JPetStore_1.3”，该快照关联 JPetStore_APP 1.3 版本、JPetStore_WEB 1.0 版本和 JPetStore_DB 1.1 版本。</p><blockquote><p>图 11. 创建应用快照</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image027.jpg" alt=""></p><h3 id="设置-JPetStore-应用组件的状态"><a href="#设置-JPetStore-应用组件的状态" class="headerlink" title="设置 JPetStore 应用组件的状态"></a>设置 JPetStore 应用组件的状态</h3><p>如果 JPetStore 应用在系统集成环境已成功部署，并通过系统集成测试，质量工程师则把组件的状态设置为”组件经过 SIT 测试”，对 JPetStore-WEB 1.0 和 JPetStore-DB 1.1 的版本状态也按此设置。这样确保这些组件版本能部署到用户验收测试环境下。<br>图 12. 设置应用组件状态<br><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image029.jpg" alt=""></p><h3 id="把-JPetStore-的-1-3-版本部署到-UAT-环境"><a href="#把-JPetStore-的-1-3-版本部署到-UAT-环境" class="headerlink" title="把 JPetStore 的 1.3 版本部署到 UAT 环境"></a>把 JPetStore 的 1.3 版本部署到 UAT 环境</h3><p>部署工程师选择 JPetStore 应用，执行在 UAT 环境上部署，并选择“JPetStore 1.3”快照，确保部署在 UAT 环境的版本和部署在 SIT 环境下的版本是一致的。</p><blockquote><p>图 13. 把应用快照部署到环境</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image031.jpg" alt=""></p><h3 id="查看-JPetStore-在-SIT-和-UAT-环境下的部署版本"><a href="#查看-JPetStore-在-SIT-和-UAT-环境下的部署版本" class="headerlink" title="查看 JPetStore 在 SIT 和 UAT 环境下的部署版本"></a>查看 JPetStore 在 SIT 和 UAT 环境下的部署版本</h3><p>质量工程师可通过如下界面获得应用在不同环境下所部署的版本，并可比较不同环境下部署版本之间的差异。下图显示的是 JPetStore 应用在 SIT 和 UAT 环境下部署的版本。</p><blockquote><p>图 14. 查看环境中部署的组件版本</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image033.jpg" alt=""></p><h2 id="统计-JPetStore-应用的部署情况"><a href="#统计-JPetStore-应用的部署情况" class="headerlink" title="统计 JPetStore 应用的部署情况"></a>统计 JPetStore 应用的部署情况</h2><p>所有人员可通过 UCD 提供的报告能力对部署情况进行统计。比如，下图是对 JPetStore 应用的部署情况的统计报告。</p><blockquote><p>图 15. 查看应用部署统计信息</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/image035.jpg" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>针对企业应用在多环境、高频率下的部署，IBM UrbanCode 基于完善的应用部署管理信息模型，可视化的应用部署管理界面，帮助企业提高应用部署的自动化水平、部署管控和审计水平。</p><p>转自：<a href="https://www.ibm.com/developerworks/cn/rational/1401_yangmq_urbancode/" target="_blank" rel="noopener">利用 IBM UrbanCode Deploy 实现企业应用部署自动化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;企业应用部署面临的挑战分析述&quot;&gt;&lt;a href=&quot;#企业应用部署面临的挑战分析述&quot; class=&quot;headerlink&quot; title=&quot;企业应用部署面临的挑战分析述
      
    
    </summary>
    
      <category term="工具" scheme="https://anshenzheng.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="UDeploy" scheme="https://anshenzheng.github.io/tags/UDeploy/"/>
    
      <category term="CI" scheme="https://anshenzheng.github.io/tags/CI/"/>
    
      <category term="Deploy" scheme="https://anshenzheng.github.io/tags/Deploy/"/>
    
  </entry>
  
  <entry>
    <title>Cassandra 概要介绍</title>
    <link href="https://anshenzheng.github.io/2017/08/01/Cassandra%20%E6%A6%82%E8%A6%81%E4%BB%8B%E7%BB%8D/"/>
    <id>https://anshenzheng.github.io/2017/08/01/Cassandra 概要介绍/</id>
    <published>2017-08-01T04:39:57.000Z</published>
    <updated>2017-08-01T12:44:08.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Cassandra只一个开源分布式NoSQL数据库，具有高度可扩展性和高可用性，可用于管理大量的结构化和非结构化数据, 主要特性如下:</p><ul><li>持续可用性, 易于管理大量服务器和不会有单点故障</li><li>支持非常方便的列索引, 高性能的日志结构数据更新，强大的非规格化和物化视图以及缓存功能</li><li>采用去中心化的架构<br>所有的节点都是平等的, Cassandra自动化地在环或者说数据库集群的所有节点之间进行数据分发<br>开发人员或管理人员无法也没必要通过程序来控制数据分发，因为集群里所有几点的数据分区对用户是透明的</li><li>提供了内建的可定制的replication机制, 在整个集群的节点上保存冗余的数据副本</li><li>具有线性扩展性，也就是说可以简单的在线添加新节点从而增加集群的处理能力<br>例如，如果每两个节点每秒处理100,000个事务, 4个几点就能每秒处理200,000个事务。</li></ul><h3 id="Cassandra基本数据模型"><a href="#Cassandra基本数据模型" class="headerlink" title="Cassandra基本数据模型"></a>Cassandra基本数据模型</h3><h4 id="Cluster-集群"><a href="#Cluster-集群" class="headerlink" title="Cluster 集群"></a>Cluster 集群</h4><p>Cassandra数据分布在不同的机器集群节点上。</p><h4 id="Keyspace"><a href="#Keyspace" class="headerlink" title="Keyspace"></a>Keyspace</h4><p>Keyspace相当于关系数据库中的数据库，是一系列Column Family的集合。<br>创建keyspace时需指定如下几种属性：</p><ul><li><p>replication_factor 复制因子<br>集群中接收相同数据副本的计算机数。</p></li><li><p>stategry class 副本放置策略</p></li></ul><ol><li><p>SimpleStrategry 简单策略<br>为集群指定简单的复制因子</p></li><li><p>旧网络拓扑策略<br>单独为每个数据中心设置复制因子</p></li><li><p>网络拓扑策略<br>单独为每个数据中心设置复制因子</p><p>创建语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> KEYSPACE Keyspace <span class="keyword">name</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">replication</span>=&#123;<span class="string">'class'</span>: <span class="string">'SimpleStrategry'</span>, <span class="string">'replication_factor'</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Keysspace示意图<br><img src="http://www.web3.xin/uploads/image/2017/02/12/20170212103220_60671.jpg" alt=""></p><h4 id="Column-Family"><a href="#Column-Family" class="headerlink" title="Column Family"></a>Column Family</h4><p>Column Family相当于关系数据库中的表，是一系列Column的集合，在该集合中，每个Column都会有一个与之相关联的键：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Authors = &#123;</span><br><span class="line">  <span class="string">"1234"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Harry"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">18</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"5678"</span>:&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Lucy"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">19</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h4><p>Column是Cassandra所支持的最基础的数据模型，可以包含一系列的键值对：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Author Name"</span>,</span><br><span class="line">  <span class="string">"value"</span>: <span class="string">"Harry"</span>,</span><br><span class="line">  <span class="string">"timestamp"</span>: <span class="number">123456789</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Super-Column"><a href="#Super-Column" class="headerlink" title="Super Column"></a>Super Column</h4><p>Super Column是包含了一系列Column:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Cassandra Introduction"</span>,</span><br><span class="line">  <span class="string">"value"</span>: &#123;</span><br><span class="line">    <span class="string">"author"</span>: &#123;<span class="string">"name"</span>: <span class="string">"Author Name"</span>, <span class="string">"value"</span>: <span class="string">"Harry"</span>, <span class="string">"timestamp"</span>: <span class="string">"123456789"</span>&#125;,</span><br><span class="line">    <span class="string">"publisher"</span>: &#123;<span class="string">"name"</span>:<span class="string">"Publisher"</span>, <span class="string">"value"</span>: <span class="string">"China Press"</span>, <span class="string">"timestamp"</span>: <span class="number">223154878</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>Cassandra官方文档不建议过多使用Super Column</p></blockquote><h4 id="Primary-Key-amp-Composite-Key-amp-Partition-Key-amp-Clustering-Key"><a href="#Primary-Key-amp-Composite-Key-amp-Partition-Key-amp-Clustering-Key" class="headerlink" title="Primary Key &amp; Composite Key &amp; Partition Key &amp; Clustering Key"></a>Primary Key &amp; Composite Key &amp; Partition Key &amp; Clustering Key</h4><p>主键, 定义Cassandra数据表时指定，可以指定一个字段也可以指定多个字段。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">user_id <span class="built_in">text</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">user_name <span class="built_in">text</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>组合主键 - Composite Key, 下例中key_one和key_two组成Composite Key.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sampe(</span><br><span class="line"> key_one <span class="built_in">text</span>,</span><br><span class="line"> key_two <span class="built_in">text</span>,</span><br><span class="line"> <span class="keyword">data</span> <span class="built_in">text</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span>(key_one, key_two)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>Composite key中的第一组成为Partition Key, 后面各组称为Clustering Key.</p><p>Partition Key用于决定Cassandra会使用集群中哪个结点来记录该数据， 每个PartitionKey对应着一个Parition.<br>Clustering Key用来在Partition内部排序。</p><p>在CQL语句中， WHERE等子句所标识的条件只能使用在Primary Key中所使用的列。</p><h3 id="COL-Cassandra-Query-Language"><a href="#COL-Cassandra-Query-Language" class="headerlink" title="COL - Cassandra Query Language"></a>COL - Cassandra Query Language</h3><h3 id="Java中Cassandra数据库的操作"><a href="#Java中Cassandra数据库的操作" class="headerlink" title="Java中Cassandra数据库的操作"></a>Java中Cassandra数据库的操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Cluster cluster = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//创建连接到Cassandra客户端</span></span><br><span class="line">  cluster = Cluster.builder()</span><br><span class="line">                   .addContactPoint(<span class="string">"127.0.0.1"</span>)</span><br><span class="line">                   .build();</span><br><span class="line">  <span class="comment">//创建用户会话</span></span><br><span class="line">  Session session = cluster.connect();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//执行CQL语句</span></span><br><span class="line">  ResultSet rs = session.execute(<span class="string">"select release_version from system.local"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//从返回结果中取出第一条结构</span></span><br><span class="line">  Row row = rs.one();</span><br><span class="line">  </span><br><span class="line">   System.out.println(row.getString(<span class="string">"release_version"</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建并使用keyspace </span></span><br><span class="line">  String query = <span class="string">"CREATE KEYSPACE tp WITH replication = &#123;'class':'SimpleStrategry', 'replication_factor':3&#125;"</span>;</span><br><span class="line">  session.execute(query);</span><br><span class="line">  session.execute(<span class="string">"USE tp"</span>);</span><br><span class="line">  </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cluster != <span class="keyword">null</span>)&#123;</span><br><span class="line">    cluster.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cassandra内部存储结构"><a href="#Cassandra内部存储结构" class="headerlink" title="Cassandra内部存储结构"></a>Cassandra内部存储结构</h3><p>Cassandra写入数据之前，需要先记录日志(CommitLog), 然后数据开始写入到ColumnFamily对应的Memtable中,Memtable是一种按照Key排序数据的内存结构，在满足一定条件时，再把Memtable中的数据批量持久化到磁盘上，存储在SSTable中。</p><p>Cassandra数据信息分为3类：</p><ul><li>data目录<br>用户存储真正的数据文件，是SSTable文件, 可以指定多个目录</li><li>commitlog目录<br>用于存储未写入SSTable中的数据</li><li>cache目录<br>用户存储系统中的缓存数据，在服务重启时，从此目录加载缓存数据。</li></ul><p>参考：<br><a href="http://www.web3.xin/cassandra/174.html" target="_blank" rel="noopener">cassandra教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;Cassandra只一个开源分布式NoSQL数据库，具有高度可扩展性和高可用性，可用于管理大量的结构化和非结构化数据, 主要特性如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;持续可用性,
      
    
    </summary>
    
      <category term="数据库" scheme="https://anshenzheng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Cassandra" scheme="https://anshenzheng.github.io/tags/Cassandra/"/>
    
      <category term="NoSQL" scheme="https://anshenzheng.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>分布式应用架构学习（一）</title>
    <link href="https://anshenzheng.github.io/2017/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://anshenzheng.github.io/2017/07/15/分布式应用架构学习/</id>
    <published>2017-07-15T04:25:42.000Z</published>
    <updated>2017-07-15T04:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="分布式应用架构的演变"><a href="#分布式应用架构的演变" class="headerlink" title="分布式应用架构的演变"></a>分布式应用架构的演变</h3><p>随着互联网的快速发展和演进, 不断变化的商业环境所带来的业务需求, 使得单一应用架构越来越复杂, 越来越难以支撑业务体系的发展。</p><p>因此系统拆分就成了不可避免的事情, 由此演变为垂直应用架构体系。</p><p>垂直应用架构解决了单一应用所面临的扩容问题, 流量可以分散到各个子系统中, 且系统体积可控, 一定程度上降低了开发人员之间协同和维护的成本, 提升了开发效率。</p><p>当垂直应用越来越多达到一定规模时, 应用之间的相互交互和调用不可避免。否则不同系统之间存在着重叠的业务, 容易形成信息孤岛, 重复造轮子。此时相对核心的业务会被抽取出来, 作为单独的系统对外提供服务, 达成业务之间的相互复用,x系统也因此演变为分布式应用架构体系。</p><p><img src="http://images.cnblogs.com/cnblogs_com/developerERA/1034447/o_%e5%88%86%e5%b8%83%e5%bc%8f%e5%ba%94%e7%94%a8%e6%9e%b6%e6%9e%84%e7%9a%84%e6%bc%94%e5%8f%98.png" alt=""></p><p>分布式应用架构所面临的首要问题, 便是如何实现应用之间的远程调用(RPC)。</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC全称是Remote Process Call, 即远程过程调用。<br>RPC将原本本地调用转变为调用远端服务器上的方法, 给系统的处理能力和吞吐量带来了近似无限制提升的可能, 这是系统发展到一定阶段的必然改革, 也是分布式计算的基础。</p><h4 id="RPC调用示意-服务调用方调用服务提供方的服务"><a href="#RPC调用示意-服务调用方调用服务提供方的服务" class="headerlink" title="RPC调用示意 (服务调用方调用服务提供方的服务)"></a>RPC调用示意 (服务调用方调用服务提供方的服务)</h4><p><img src="http://images.cnblogs.com/cnblogs_com/developerERA/1034447/t_6d30fe08853cf8fbccd80c96323bfe7c.png" alt=""></p><h4 id="基于HTTP协议的RPC"><a href="#基于HTTP协议的RPC" class="headerlink" title="基于HTTP协议的RPC"></a>基于HTTP协议的RPC</h4><ul><li>使用灵活</li><li>实现便捷</li><li>开放(国际标准)</li><li>天生支持异构平台之间的调用</li></ul><h4 id="基于TCP协议的RPC"><a href="#基于TCP协议的RPC" class="headerlink" title="基于TCP协议的RPC"></a>基于TCP协议的RPC</h4><ul><li>效率高</li><li>实现复杂</li><li>跨平台难</li></ul><h3 id="业界主流RPC框架"><a href="#业界主流RPC框架" class="headerlink" title="业界主流RPC框架"></a>业界主流RPC框架</h3><ul><li>Apache Thrift</li></ul><p>由Facebook开发的高效支持多种编程语言的远程服务调用框架，采用接口描述语言定义创建，支持跨语言服务开发，可以与主流语言无缝衔接，采用二进制格式传输数据，对高并发，大数据量和多语言的环境比较有优势。</p><ul><li>Avro-RPC</li></ul><p>Hadoop的子项目，支持丰富的数据结构类型，可定制性强，传输层和业务层分离，用户可以专注于业务逻辑的开发。</p><ul><li>Hessian</li></ul><p>Caucho提供的给予binary-RPC实现的轻量级二进制远程通信框架，通过Servlet提供远程服务，可以将某个请求映射到Hessian服务。<br>简单易用，面向接口编程，支持多语言，可与Spring集成。</p><ul><li>gRPC</li></ul><p>Google开源的基于HTTP/2和ProtoBuf的通用RPC框架，支持多语言，基于http2的设计带来诸如双向流，流控，头部压缩，单TCP连接上的多复用请求等特性。</p><p>随着业务的发展, 服务调用者的规模发展到一定阶段, 对服务提供方的压力也日益增加, 因此服务需要进行扩容。<br>而随着服务提供者的增加与业务的发展, 不同服务之间还需要进行分组, 以隔离不同业务, 避免相互影响, 此时, 服务的路由和负载均衡则成为必须要考虑的问题。</p><h4 id="服务分组路由与负载均衡架构"><a href="#服务分组路由与负载均衡架构" class="headerlink" title="服务分组路由与负载均衡架构"></a>服务分组路由与负载均衡架构</h4><p><img src="http://images.cnblogs.com/cnblogs_com/developerERA/1034447/o_6f2c88b0cbd5500de5b283b4e1fc2cef.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;分布式应用架构的演变&quot;&gt;&lt;a href=&quot;#分布式应用架构的演变&quot; class=&quot;headerlink&quot; title=&quot;分布式应用架构的演变&quot;&gt;&lt;/a&gt;分布式应用架
      
    
    </summary>
    
      <category term="架构" scheme="https://anshenzheng.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="分布式" scheme="https://anshenzheng.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="架构" scheme="https://anshenzheng.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="RPC" scheme="https://anshenzheng.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>UML概论</title>
    <link href="https://anshenzheng.github.io/2017/07/13/UML%E6%A6%82%E8%AE%BA/"/>
    <id>https://anshenzheng.github.io/2017/07/13/UML概论/</id>
    <published>2017-07-13T06:04:58.000Z</published>
    <updated>2017-07-13T12:32:13.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="http://images2015.cnblogs.com/blog/1105627/201706/1105627-20170621181142038-1669847124.png" alt=""></p><p>在建筑业中, 建模是一项经过检验并被广泛接受的工程技术, 建立房屋和大厦的建筑模型, 能帮助用户得到实际建筑物的印象。在软件建模中也具有同样的作用, 建模提供了系统的蓝图。</p><p>建模是为了能够更好地理解正在开发的系统而建立的。通过建模有以下优点：</p><ul><li>有助于按照实际情况或按照所需要的样式对系统进行可视化</li><li>能够规约系统的结构或行为</li><li>给出了指导构造系统的模板</li><li>对做出决策进行文档化</li></ul><h3 id="UML基本构成元素"><a href="#UML基本构成元素" class="headerlink" title="UML基本构成元素"></a>UML基本构成元素</h3><p>UML由图和元模型组成, 主要包括3个基本构造块：</p><h4 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h4><p>事物是实体抽象化的最终结果, 是模型中的基本成员, UML中包括结构事物, 行为事物, 分组事物和注释事物</p><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>关系是将事物联系在一起的方式, UML中定义了4中关系, 即</p><ul><li>依赖（两种事物之间的语义关系，其中一个事物发生变化会影响另一个事物的语义）</li><li>关联（描述一组对象之间连接的结构关系）</li><li>泛化（一种一般化到特殊化的关系）</li><li>实现（类之间的语义关系，其中的一个类制定了由另一个类保证执行的契约）</li></ul><h4 id="图-常见有以下10种图"><a href="#图-常见有以下10种图" class="headerlink" title="图(常见有以下10种图)"></a>图(常见有以下10种图)</h4><h5 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h5><ul><li>描述系统需求</li></ul><h5 id="类图、对象图、包图"><a href="#类图、对象图、包图" class="headerlink" title="类图、对象图、包图"></a>类图、对象图、包图</h5><ul><li>描述软件结构</li></ul><h5 id="组件图、部署图"><a href="#组件图、部署图" class="headerlink" title="组件图、部署图"></a>组件图、部署图</h5><ul><li>描述硬件结构</li></ul><h5 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h5><ul><li>描述对象静态状态的转换</li></ul><h5 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h5><ul><li>描述对象动态活动的转换</li></ul><h5 id="序列图"><a href="#序列图" class="headerlink" title="序列图"></a>序列图</h5><ul><li>描述多个对象之间在时间上的交互</li></ul><h5 id="协作图"><a href="#协作图" class="headerlink" title="协作图"></a>协作图</h5><ul><li>描述多个对象之间在空间上的交互</li></ul><p>下面的思维导图版的UML概要总结：<br><img src="http://images2015.cnblogs.com/blog/1105627/201707/1105627-20170713135033212-783534247.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/1105627/201706/1105627-20170621181142038-1
      
    
    </summary>
    
      <category term="架构" scheme="https://anshenzheng.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="UML" scheme="https://anshenzheng.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>Autonomy IDOL</title>
    <link href="https://anshenzheng.github.io/2017/07/11/Autonomy%20IDOL%E6%A6%82%E8%A6%81%E5%9B%9E%E9%A1%BE/"/>
    <id>https://anshenzheng.github.io/2017/07/11/Autonomy IDOL概要回顾/</id>
    <published>2017-07-11T14:00:44.000Z</published>
    <updated>2017-07-11T14:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>几年前在HP曾做过几个Autonomy IDOL(现在的HPE IDOL)相关的项目, IDOL的功能相当强大, 而我们只主要用到了的相关性查询, 情感分析, Logo识别, 人脸识别等功能, 有点杀鸡用牛刀的味道。</p><p>当时为了这个项目, 项目组还特意给我们申请了价值几百美金的Autonomy内部系列培训课程, 后来经过做项目过程中的层层实践和磨练, 一度成为项目组内部Autonomy专家, 安装、配置、接口使用，甚至于新功能的自我摸索和学习也不在话下。</p><p>但是Autonomy毕竟是一个大块头超昂贵的系统, 功能很强大, 卖的License自然也很贵, 所以一般可能只有某些大公司在使用, 大部分的中小公司是用不起的, 这也就决定了这门技术在需要的地方很吃香，但是很多地方都不需要。</p><p>几年过去了,由于之前的疏忽没有做过总结,大部分的知识都快忘光了,不过鉴于<a href="https://my.vertica.com/documentation/idol/11-0/" target="_blank" rel="noopener">官网</a>还是有比较详细的教程,这里只概要回顾一下:</p><p>Autonomy提供了一种能够理解任何文件格式的全面软件基础架构解决方案。无论数据是文字还是语音，是结构化还是非结构化，采用何种创建和存储手段，Autonomy都可以进行处理。Autonomy的技术使企业应用系统独立于数据类型而运作，同时借助将手工操作自动化而提升了效率。</p><h2 id="IDOL的工作流"><a href="#IDOL的工作流" class="headerlink" title="IDOL的工作流"></a>IDOL的工作流</h2><p><img src="https://my.vertica.com/docs/IDOL/Servers/IDOLServer/11.0/Guides/html/English/expert/Content/IDOLExpert/Images/IDOLArchitecture.png" alt=""></p><h2 id="IDOL中的一些常用组件："><a href="#IDOL中的一些常用组件：" class="headerlink" title="IDOL中的一些常用组件："></a>IDOL中的一些常用组件：</h2><h3 id="License-Server"><a href="#License-Server" class="headerlink" title="License Server"></a>License Server</h3><p>Autonomy的使用时基于license的，每一个license对应一个MAC地址。IDOL提供的大部分服务都必须有license才能正常工作。</p><h3 id="Connectors"><a href="#Connectors" class="headerlink" title="Connectors"></a>Connectors</h3><p>Connectors是IDOL平台的一个核心组件，它可以灵活而精准的把不同格式(结构化，半结构化，上千种文件格式)不同来源的数据摄入到IDOL数据库中。常用的Connectors有如下几种：</p><ul><li><p>ODBC Connector<br>通过配置可以直接连接所有支持ODBC的数据库，通过配置的SQL语句，直接从数据库中抽取数据。</p></li><li><p>File Connector<br>可以从指定的本地或网络文件目录抽取文件内容到IDOL中。</p></li><li><p>Http Connector<br>可以从指定的网站抓取内容。</p></li></ul><h3 id="CFS-Connector-Framework-Server"><a href="#CFS-Connector-Framework-Server" class="headerlink" title="CFS (Connector Framework Server)"></a>CFS (Connector Framework Server)</h3><p>Connectors实现了如何从不同的数据源抽取数据，CFS则负责抽取的实施以及从抽取的文件中提取出元数据(metadata)和文件内容，并把它们加载的CFS的document中。这样IDOL Server可以直接搜索分析数据，而不需要再从原文件格式中提取数据。<br>在数据进入IDOL数据库之前，还可以做一些增强操作，比如文字的情感分析， 文档归类， 概要生成等。<br>增加了CFS这一层，是将所需要的数据提供了一个统一的入口，相当于从各种管道接来了水，放置在水池中，供IDOL来用。</p><h3 id="IDOL-Server"><a href="#IDOL-Server" class="headerlink" title="IDOL Server"></a>IDOL Server</h3><p>IDOL - 智能数据操作层(Intelligent Data Operating Layer)是Autonomy的核心，它可以收集来自各种连接器(Connectors)的数据, 并以其能够实现快速处理和检索的独特结构存储这些数据。在处理信息的时候，IDOL能够联系概念和语境来理解数据中的内容，可以对超过一千种不同格式的信息进行自动分析。</p><p>IDOL允许对数据源进行超过500多种操作，包括超链接、代理、摘要、分类、聚类、结构化信息抽取、档案建立、个性化信息提醒及检索。</p><h3 id="Image-Server"><a href="#Image-Server" class="headerlink" title="Image Server"></a>Image Server</h3><p>用于图片内容的存储分析查询等，可以从图片中提取文字，通过图片训练还可以提供Logo识别，人脸识别等功能。</p><h3 id="DAH-Distributed-Action-Handler"><a href="#DAH-Distributed-Action-Handler" class="headerlink" title="DAH (Distributed Action Handler)"></a>DAH (Distributed Action Handler)</h3><p>用于分布式查询和结果集的整理。</p><h3 id="DIH-Distributed-Action-Handler"><a href="#DIH-Distributed-Action-Handler" class="headerlink" title="DIH (Distributed Action Handler)"></a>DIH (Distributed Action Handler)</h3><p>用于分布式索引, 将即将入库的文档分散为子集发送到集群中的各个server。</p><h3 id="Query-Manipulation-Server"><a href="#Query-Manipulation-Server" class="headerlink" title="Query Manipulation Server"></a>Query Manipulation Server</h3><p>查询管理。</p><h3 id="Eduction-Server"><a href="#Eduction-Server" class="headerlink" title="Eduction Server"></a>Eduction Server</h3><p>为自己感兴趣的实体增加tag以便于查询和过滤。</p><h3 id="Media-Server"><a href="#Media-Server" class="headerlink" title="Media Server"></a>Media Server</h3><p>分析处理视频数据，可以将视频分解为音频和图片，将音频转换为文字等。</p><h3 id="IDOL-Speech-Server"><a href="#IDOL-Speech-Server" class="headerlink" title="IDOL Speech Server"></a>IDOL Speech Server</h3><p>分析处理音频文件， 可以实现音频转换为文字，语音识别及语音搜索等功能。</p><h2 id="IDOL中支持的功能："><a href="#IDOL中支持的功能：" class="headerlink" title="IDOL中支持的功能："></a>IDOL中支持的功能：</h2><p><img src="https://my.vertica.com/docs/IDOL/Servers/IDOLServer/11.0/Guides/html/English/expert/Content/FunctionalityView.png" alt=""></p><h2 id="IDOL的应用架构"><a href="#IDOL的应用架构" class="headerlink" title="IDOL的应用架构"></a>IDOL的应用架构</h2><p><img src="http://blogs.forrester.com/f/b/users/LOWENS/autonomy.jpg" alt=""></p><p>参考文档： <a href="https://my.vertica.com/documentation/idol/11-0/" target="_blank" rel="noopener">https://my.vertica.com/documentation/idol/11-0/</a><br><a href="https://my.vertica.com/docs/IDOL/Interfaces/ACIAPI/11.0/Guides/pdf/English/ACIAPI_11.0_Programming_en.pdf" target="_blank" rel="noopener">应用接口使用文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;几年前在HP曾做过几个Autonomy IDOL(现在的HPE IDOL)相关的项目, IDOL的功能相当强大, 而我们只主要用到了的相关性查询, 情感分析, Logo识别,
      
    
    </summary>
    
      <category term="大数据" scheme="https://anshenzheng.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="搜索" scheme="https://anshenzheng.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="Autonomy" scheme="https://anshenzheng.github.io/tags/Autonomy/"/>
    
  </entry>
  
  <entry>
    <title>常见分布式全局唯一ID生成方案</title>
    <link href="https://anshenzheng.github.io/2017/07/11/%E5%B8%B8%E8%A7%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"/>
    <id>https://anshenzheng.github.io/2017/07/11/常见分布式全局唯一ID生成方案/</id>
    <published>2017-07-11T14:00:44.000Z</published>
    <updated>2017-07-11T14:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>一般而言，几乎在任何系统中，我们都需要使用唯一的ID去识别以及操作应用中的对象，比如对用户管理而言需要用户ID，对订单管理而言需要订单ID。</p><p>在小的项目中，我们可以直接使用数据库的自增长特性来生成主键的ID，这样简单且易实现。但是在分库分表的分布式环境中，数据往往分布在不同的分片上，如果再通过数据库的自增长特性，势必会造成主键重复。</p><p>这就需要我们采用一些分布式全局唯一ID的生成方案，以下介绍几种常见的全局ID生成方案：</p><h3 id="Twitter的Snowflake算法-雪花算法"><a href="#Twitter的Snowflake算法-雪花算法" class="headerlink" title="Twitter的Snowflake算法(雪花算法)"></a>Twitter的Snowflake算法(雪花算法)</h3><p>Twitter服务器上每秒钟都会有上百万条新的Twitter消息产生，每条消息都需要分配唯一的ID，而且为了方便客户端的排序，这些ID还需要一些大致的书序，为了解决这样一个问题，Twitter创建了Snowflake算法。</p><h4 id="Snowflake算法核心"><a href="#Snowflake算法核心" class="headerlink" title="Snowflake算法核心"></a><a href="https://github.com/twitter/snowflake/tree/snowflake-2010" target="_blank" rel="noopener">Snowflake</a>算法核心</h4><p>Twitter生成的ID是64bits整数型，64位组成结构如下：<br>标记位(1位，不可用)+时间戳(41位) + 机器ID(10位) + 序列号(12位)</p><ul><li><p>标记位<br>标记位一般为0， 不可以使用。</p></li><li><p>时间戳<br>时间戳有41位，可以表示的数据为0 ~ 2^41，这里的时间戳的细度是毫秒级的，那么计算可知可以使用 2^41/(365<em>24</em>60<em>60</em>1000) = 69.73年。<br>具体生成代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64_t <span class="title">generateStamp</span><span class="params">()</span></span>&#123;</span><br><span class="line">timeval tv;</span><br><span class="line">gettimeofday(&amp;tv, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (uint64v_t)tv.tv_sec*<span class="number">1000</span> + (uint64v_t)tv.tv_usec/<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>机器ID<br>机器位有10位， 2^10 = 1024, 即可以支持1024台机器。</p></li><li><p>序列号位<br>序列号分配有12位，2^12 = 4096, 即每毫秒支持产生4096个自增序列的ID。</p></li></ul><h3 id="UUID-GUID"><a href="#UUID-GUID" class="headerlink" title="UUID/GUID"></a>UUID/GUID</h3><p>UUID是一个由4个连字号(-)将32个字符长的字符串分割后生成的字符串,总共长36个字符长，它的生成主要基于以下几部分组合：</p><ol><li>当前的日期和时间</li><li>时钟序列</li><li>全局唯一的机器识别号(如果有网卡就从网卡的MAC地址获得,如果没有就以其它方式获得)</li></ol><p>GUID(Globally Unique Identifier)是微软对UUID标准的实现,它是根据机器网卡的MAC地址再加上一个特定算法产生的二进制长度为128位的字符表示符。</p><p>UUID/GUID唯一的缺点是生成的结果比较长.</p><p>Java中UUID生成代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">String uuid = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//去掉"-"的UUID</span></span><br><span class="line">String shortUUID = str.substring(<span class="number">0</span>, <span class="number">8</span>) + str.substring(<span class="number">9</span>, <span class="number">13</span>) + str.substring(<span class="number">14</span>, <span class="number">18</span>) + str.substring(<span class="number">19</span>, <span class="number">23</span>) + str.substring(<span class="number">24</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(uuid);</span><br><span class="line">System.out.println(shortUUID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="MongoDB-ObjectID"><a href="#MongoDB-ObjectID" class="headerlink" title="MongoDB ObjectID"></a>MongoDB ObjectID</h3><p>Mongodb会为每条插入collection不包含”id”的记录自动生成一个24位字符长的objectId, 例如”4e7020cb7cac81af7136236b”.</p><p>这个24位的字符串实际上由一组16禁止的字符构成，每个字节两位十六禁止数字，总共用了12字节的存储空间。</p><p>根据官网中ObjectId规范的描述，它的组成结构如下:<br><img src="http://pic002.cnblogs.com/images/2011/83478/2011091823160647.png" alt=""></p><ul><li><p>时间戳(4bytes - 32bits)<br>将前4位进行提取，然后按照十六进制转换成十进制，就可以得到一个时间</p></li><li><p>机器ID(3bytes - 24bits)<br>接下来3个字节是所在主机的唯一表示符，一般是主机名的散列值。</p></li><li><p>进程ID - PID(2bytes - 16bits)<br>pid是为了在同一机器下不同mongodb进程产生的objectID不冲突。</p></li><li><p>自增计数器 - INC(3bytes - 24bits)<br>确保同一秒内产生的objectId也不会冲突。</p></li></ul><p>参考文章：<a href="http://www.cnblogs.com/xjk15082/archive/2011/09/18/2180792.html" target="_blank" rel="noopener">MongoDB深究之ObjectId</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;一般而言，几乎在任何系统中，我们都需要使用唯一的ID去识别以及操作应用中的对象，比如对用户管理而言需要用户ID，对订单管理而言需要订单ID。&lt;/p&gt;
&lt;p&gt;在小的项目中，我们
      
    
    </summary>
    
      <category term="架构" scheme="https://anshenzheng.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="分布式" scheme="https://anshenzheng.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="ID" scheme="https://anshenzheng.github.io/tags/ID/"/>
    
  </entry>
  
  <entry>
    <title>Cache相关的HTTP请求/响应头</title>
    <link href="https://anshenzheng.github.io/2017/07/10/Cache%E7%9B%B8%E5%85%B3%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E5%A4%B4/"/>
    <id>https://anshenzheng.github.io/2017/07/10/Cache相关的HTTP请求响应头/</id>
    <published>2017-07-10T14:02:49.000Z</published>
    <updated>2017-07-10T14:05:16.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>常见的HTTP请求/响应头有很多，以下介绍几种cache相关的：</p><ul><li>Pragma</li><li>Cache-Control</li><li>Expires</li><li>Last-Modified</li><li>Etag</li></ul><h3 id="Pragma-amp-Cache-Control"><a href="#Pragma-amp-Cache-Control" class="headerlink" title="Pragma &amp; Cache-Control"></a>Pragma &amp; Cache-Control</h3><p>用于指定所有缓存机制在整个请求/响应链中必须服从的命令，如果知道该页面是否为缓存，不仅可以控制浏览器，还可以控制HTTP协议相关的缓存或者代理服务器。</p><p>Cache-Control请求字段优先级比较高，如果和其它一些相冲突的字段(比如Expires)同时出现，则Cache-Control会覆盖其它字段。<br>Pragma的作用和Cache-Control类似，也是在HTTP头中包含一个特殊指令，使相关的服务器来遵守，Pragma:no-cache 和 Cache-Control:no-cache的作用是一样的。</p><blockquote><p>浏览器中的强制刷新(Ctrl + F5)就是通过发起请求时加上请求头 Pragma:no-cache 和 Cache-Control:no-cache 实现的。</p></blockquote><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>通常格式为Expires:Sat,25Feb201712:22:17GMT,后面跟着日期和时间，超过这个时间值后，缓存内容将失效，也就是浏览器在发出请求之前会检查这个页面的字段，如果页面已经过期，就重新向服务器发起请求。</p><h3 id="Last-Modified-amp-Etag"><a href="#Last-Modified-amp-Etag" class="headerlink" title="Last-Modified &amp; Etag"></a>Last-Modified &amp; Etag</h3><p>Last-Modified一般用于表示一个服务器上的资源的最后修改时间，资源可以是静态或者是动态的。<br>一般服务端在响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间，浏览器再次请求时在请求头中增加一个If-Modified-Since:Sat,25Feb201712:22:17GMT,询问当前缓存的页面是否是最新的，如果是最新的就返回304，告诉浏览器是最新的，服务器也不会传输新的数据。</p><p>Etag与Last-Modified功能类似，作用是让服务器给每个页面分配一个唯一的编号，然后通过编号来区分当前页面是否为最新。这种方式比Last-Modified更灵活，但是在后端的Web服务器有多台时就比较难处理，因为每个web服务器都要记住网站的所有资源，否则这个编号就没有意义了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;常见的HTTP请求/响应头有很多，以下介绍几种cache相关的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pragma&lt;/li&gt;
&lt;li&gt;Cache-Control&lt;/li&gt;
&lt;li&gt;Ex
      
    
    </summary>
    
      <category term="前端" scheme="https://anshenzheng.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="cache" scheme="https://anshenzheng.github.io/tags/cache/"/>
    
      <category term="http" scheme="https://anshenzheng.github.io/tags/http/"/>
    
      <category term="web" scheme="https://anshenzheng.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中的闭包</title>
    <link href="https://anshenzheng.github.io/2017/07/10/Javascript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <id>https://anshenzheng.github.io/2017/07/10/Javascript中的闭包/</id>
    <published>2017-07-10T14:02:49.000Z</published>
    <updated>2017-07-10T14:02:49.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包(closure)是指在JavaScript中，将外部函数中的局部变量封闭起来的(内部)函数。<br>(被封闭起来的变量与封闭它的函数具有相同的生命周期。)</p><p>示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> local = <span class="string">"local variable"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(local);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中内部函数inner持有外部函数func的局部变量local，这样就构成了一个作用域(闭包)，通过该作用域我们可以访问及修改外部访问不到的内部变量。</p><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><p>管理私有变量和私有方法，将对变量的管理封装在安全环境之中。<br>外层函数执行之后，它的局部变量本来应该全部销毁，但是由于闭包的存在，之后执行内部函数，通过它仍然可以访问到外层函数的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Charlie"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">setName: <span class="function"><span class="keyword">function</span>(<span class="params">new_name</span>)</span>&#123;</span><br><span class="line">name = new_name;</span><br><span class="line">&#125;,</span><br><span class="line">getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = func();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.name);</span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.getName())</span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="comment">// Charlie</span></span><br><span class="line"></span><br><span class="line">f.setName(<span class="string">"Teddy"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f.getName())</span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="comment">// Teddy</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭包&lt;/h3&gt;&lt;p&gt;闭包(closu
      
    
    </summary>
    
      <category term="前端" scheme="https://anshenzheng.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://anshenzheng.github.io/tags/javascript/"/>
    
      <category term="闭包" scheme="https://anshenzheng.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中的Prototype</title>
    <link href="https://anshenzheng.github.io/2017/07/09/Javascript%E4%B8%AD%E7%9A%84Prototype/"/>
    <id>https://anshenzheng.github.io/2017/07/09/Javascript中的Prototype/</id>
    <published>2017-07-09T14:11:25.000Z</published>
    <updated>2017-07-09T14:16:05.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="Prototype-是什么"><a href="#Prototype-是什么" class="headerlink" title="Prototype 是什么"></a>Prototype 是什么</h3><p>Javascript中，prototype是函数的一个属性，它本身是一个对象，而这个对象的构造函数指向函数本身。<br>描述比较抽象，但是通过以下代码就很容易理解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ff</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is function ff"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ff.prototype.constructor == ff);</span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>由上也不难推出以下几个特殊对象的prototype：</p><ul><li>Array.prototype 是一个数组</li><li>String.prototype 是一个字符串</li><li>Object.prototype 是一个对象</li></ul></blockquote><p>需要注意的是，prototype属性只能用于函数，如果引用某个具体对象的prototye属性，则其为undefined。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ff</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is function ff"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ff.prototype); </span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(ff.prototype)); </span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Object</span>().prototype)</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> ff().prototype)</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">// 猜猜看是什么 :)</span></span><br></pre></td></tr></table></figure><h3 id="Prototype-有什么用"><a href="#Prototype-有什么用" class="headerlink" title="Prototype 有什么用"></a>Prototype 有什么用</h3><p>通过prototype可以为函数对象添加新的属性和方法, 所有通过 new 方法实现函数对象都会拥有新添加的方法和属性，相当于间接实现了继承。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animal.prototype.type = <span class="string">"animal"</span>;</span><br><span class="line">animal.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi, I am "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> animal(<span class="string">'cat'</span>);</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> animal(<span class="string">'dog'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat.type);</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">// animal</span></span><br><span class="line"><span class="comment">// cat</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.type);</span><br><span class="line"><span class="built_in">console</span>.log(dog.name);</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">// animal</span></span><br><span class="line"><span class="comment">// dog</span></span><br><span class="line"></span><br><span class="line">cat.sayHi();</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">// Hi, I am cat</span></span><br><span class="line">dog.sayHi();</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">// Hi, I am dog</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;Prototype-是什么&quot;&gt;&lt;a href=&quot;#Prototype-是什么&quot; class=&quot;headerlink&quot; title=&quot;Prototype 是什么&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="https://anshenzheng.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://anshenzheng.github.io/tags/javascript/"/>
    
      <category term="prototype" scheme="https://anshenzheng.github.io/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>高数常用定理及使用</title>
    <link href="https://anshenzheng.github.io/2017/07/08/%E9%AB%98%E6%95%B0%E5%B8%B8%E7%94%A8%E5%AE%9A%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>https://anshenzheng.github.io/2017/07/08/高数常用定理及使用/</id>
    <published>2017-07-08T05:37:44.000Z</published>
    <updated>2017-07-08T08:52:58.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="有界性定理"><a href="#有界性定理" class="headerlink" title="有界性定理"></a>有界性定理</h3><p>要求：只用不证<br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E6%9C%89%E7%95%8C%E6%80%A7%E5%AE%9A%E7%90%86.png?raw=true" alt=""></p><h3 id="最值定理"><a href="#最值定理" class="headerlink" title="最值定理"></a>最值定理</h3><p>要求：只用不证<br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E6%9C%80%E5%80%BC%E5%AE%9A%E7%90%86.png?raw=true" alt=""></p><h3 id="介值定理"><a href="#介值定理" class="headerlink" title="介值定理"></a>介值定理</h3><p>要求：只用不证<br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E4%BB%8B%E5%80%BC%E5%AE%9A%E7%90%861.png?raw=true" alt=""><br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E4%BB%8B%E5%80%BC%E5%AE%9A%E7%90%862.png?raw=true" alt=""></p><h3 id="积分中值定理"><a href="#积分中值定理" class="headerlink" title="积分中值定理"></a>积分中值定理</h3><p><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%A7%AF%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86.png?raw=true" alt=""></p><h3 id="积分保号定理"><a href="#积分保号定理" class="headerlink" title="积分保号定理"></a>积分保号定理</h3><p><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%A7%AF%E5%88%86%E4%BF%9D%E5%8F%B7%E6%80%A7%E5%AE%9A%E7%90%86.png?raw=true" alt=""></p><h3 id="零点定理"><a href="#零点定理" class="headerlink" title="零点定理"></a>零点定理</h3><p>要求：只用不证<br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%9B%B6%E7%82%B9%E5%AE%9A%E7%90%86.png?raw=true" alt=""></p><h3 id="费马定理"><a href="#费马定理" class="headerlink" title="费马定理"></a>费马定理</h3><p>要求：会用会证<br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E8%B4%B9%E9%A9%AC%E5%AE%9A%E7%90%86.png?raw=true" alt=""></p><h3 id="罗尔定理"><a href="#罗尔定理" class="headerlink" title="罗尔定理"></a>罗尔定理</h3><p>要求：会用会证（最重要）<br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%BD%97%E5%B0%94%E5%AE%9A%E7%90%86%E4%BD%BF%E7%94%A81.png?raw=true" alt=""><br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%BD%97%E5%B0%94%E5%AE%9A%E7%90%86%E4%BD%BF%E7%94%A82.png?raw=true" alt=""><br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%BD%97%E5%B0%94%E5%AE%9A%E7%90%86%E4%BD%BF%E7%94%A83.png?raw=true" alt=""><br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%BD%97%E5%B0%94%E5%AE%9A%E7%90%86%E4%BD%BF%E7%94%A84.png?raw=true" alt=""><br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%BD%97%E5%B0%94%E5%AE%9A%E7%90%86%E4%BD%BF%E7%94%A85.png?raw=true" alt=""></p><p>若题设条件“=”较多，则优先考虑使用罗尔定理。</p><h3 id="拉格朗日定理"><a href="#拉格朗日定理" class="headerlink" title="拉格朗日定理"></a>拉格朗日定理</h3><p><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86.png?raw=true" alt=""><br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%862.png?raw=true" alt=""></p><h3 id="柯西中值定理"><a href="#柯西中值定理" class="headerlink" title="柯西中值定理"></a>柯西中值定理</h3><p>要求：会用会证<br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E6%9F%AF%E8%A5%BF%E5%AE%9A%E7%90%861.png?raw=true" alt=""><br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E6%9F%AF%E8%A5%BF%E5%AE%9A%E7%90%862.png?raw=true" alt=""></p><h3 id="泰勒定理（公式）"><a href="#泰勒定理（公式）" class="headerlink" title="泰勒定理（公式）"></a>泰勒定理（公式）</h3><p>要求：只用不证</p><h4 id="带拉格朗日余项的公式"><a href="#带拉格朗日余项的公式" class="headerlink" title="带拉格朗日余项的公式"></a>带拉格朗日余项的公式</h4><p><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F1.png?raw=true" alt=""><br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F2.png?raw=true" alt=""></p><h4 id="带佩亚诺余项的公式"><a href="#带佩亚诺余项的公式" class="headerlink" title="带佩亚诺余项的公式"></a>带佩亚诺余项的公式</h4><p><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E4%BD%A9%E4%BA%9A%E8%AF%BA.png?raw=true" alt=""></p><h4 id="麦克劳林公式（0点展开）"><a href="#麦克劳林公式（0点展开）" class="headerlink" title="麦克劳林公式（0点展开）"></a>麦克劳林公式（0点展开）</h4><p><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%BA%A6%E5%85%8B%E5%8A%B3%E6%9E%97.png?raw=true" alt=""><br><img src="https://github.com/Anshenzheng/kao-yan-bi-ji/blob/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%BA%A6%E5%85%8B%E5%8A%B3%E6%9E%972.png?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;有界性定理&quot;&gt;&lt;a href=&quot;#有界性定理&quot; class=&quot;headerlink&quot; title=&quot;有界性定理&quot;&gt;&lt;/a&gt;有界性定理&lt;/h3&gt;&lt;p&gt;要求：只用不证&lt;
      
    
    </summary>
    
      <category term="考研" scheme="https://anshenzheng.github.io/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="高数" scheme="https://anshenzheng.github.io/tags/%E9%AB%98%E6%95%B0/"/>
    
      <category term="考研" scheme="https://anshenzheng.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的日志文件</title>
    <link href="https://anshenzheng.github.io/2017/07/07/MySQL%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"/>
    <id>https://anshenzheng.github.io/2017/07/07/MySQL中的日志文件/</id>
    <published>2017-07-07T10:08:58.000Z</published>
    <updated>2017-07-07T15:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>日志文件是数据库中非常重要的文件，可以用于操作查询，性能分析，事务保障以及数据恢复等。MySQL中的常见日志文件如下：</p><h3 id="错误日志：Error-Log"><a href="#错误日志：Error-Log" class="headerlink" title="错误日志：Error Log"></a>错误日志：Error Log</h3><p>错误日志记录了MySQL运行过程中所有较为严重的警告和错误信息，以及每次启动和关闭的详细信息。<br>默认情况下，错误记录日志功能是关闭的，错误信息会被输出到标准错误输出stderr。我们可以在启动时开启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--log-error</span><br></pre></td></tr></table></figure></p><p>选项开启错入日志功能。<br>错误日志默认以hostname.err命名存放于数据目录下， 但是可以使用命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log-error[=file_name]</span><br></pre></td></tr></table></figure></p><p>来修改存放的目录和文件名。</p><h3 id="二进制日志：Binary-Log-amp-Binary-Log-Index"><a href="#二进制日志：Binary-Log-amp-Binary-Log-Index" class="headerlink" title="二进制日志：Binary Log &amp; Binary Log Index"></a>二进制日志：Binary Log &amp; Binary Log Index</h3><p>二进制日志是MySQL中最重要的日志之一，通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--log-bin[=file_name]</span><br></pre></td></tr></table></figure></p><p>开启，MySQL会将所有修改数据库的Query(Query语句，执行时间，消耗资源，相关事务信息等)以二进制的形式记录于该日志文件。</p><p>以下是binlog的一些附加选项参数：<br>–max_binlog_size - binlog的最大存储上限，当日志达到该上限时，会自动创建一个新日志。为了保证事务安全，MySQL不会将同一个事务分开记录到两个binlog中，故有时会超出最大上限。<br>–binlog-do-db=db_name - 指明仅对db_name数据库记录binlog，忽略其它数据库执行的Query(db_name指当前正在连接的数据库)<br>–binlog-ignore-db=db_name - 功能与–binlog-do-db相反 (db_name指当前正在连接的数据库)<br>mysql-bin.index - 记录所有Binary Log的绝对路径，保证MySQL线程可以顺利的找到所需要的log文件。</p><h3 id="更新日志-Update-Log"><a href="#更新日志-Update-Log" class="headerlink" title="更新日志: Update Log"></a>更新日志: Update Log</h3><p>更新日志是MySQL在较老版本上使用的，功能与bin-log类似，以简单的文本格式记录，MySQL5.0之后不再支持。</p><h3 id="查询日志-Query-Log"><a href="#查询日志-Query-Log" class="headerlink" title="查询日志: Query Log"></a>查询日志: Query Log</h3><p>查询日志记录MySQL中所有的Query，可以通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--log[=file_name]</span><br></pre></td></tr></table></figure></p><p>来开启日志。<br>由于记录了所有的Query，包括所有的Select语句，故体积比较大，开启后对性能影响也比较大。默认文件名为数据目录下的hostname.log.</p><h3 id="慢查询日志：Slow-Query-Log"><a href="#慢查询日志：Slow-Query-Log" class="headerlink" title="慢查询日志：Slow Query Log"></a>慢查询日志：Slow Query Log</h3><p>用于记录执行时间较长的Query，通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--log-slow-queries[=file_name]</span><br></pre></td></tr></table></figure></p><p>开启，默认文件名为数据目录下的hostname-slow.log。<br>慢查询日志采用简单文本格式，记录了语句执行的时刻，消耗的时间，执行的用户以及连接主机等相关的信息。MySQL还提供了mysqlslowdump工具程序专门用来分析慢查询日志，帮助数据库管理人员解决可能存在的性能问题。</p><h3 id="InnoDB在线Redo日志：InnoDB-REDO-Log"><a href="#InnoDB在线Redo日志：InnoDB-REDO-Log" class="headerlink" title="InnoDB在线Redo日志：InnoDB REDO Log"></a>InnoDB在线Redo日志：InnoDB REDO Log</h3><p>InnoDB是一个事务安全的存储引擎，其安全性主要是通过REDO日志和记录在表空间的UNDO信息来保证的。<br>REDO日志中记录了InnoDB所做的所有物理变更和事务信息，默认存放于数据目录下，可以通过innodb_log_group_home_dir来更改日志存放位置，通过innodb_log_files_in_group设置日志数量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;日志文件是数据库中非常重要的文件，可以用于操作查询，性能分析，事务保障以及数据恢复等。MySQL中的常见日志文件如下：&lt;/p&gt;
&lt;h3 id=&quot;错误日志：Error-Log&quot;
      
    
    </summary>
    
      <category term="数据库" scheme="https://anshenzheng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://anshenzheng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="https://anshenzheng.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP的实现机制</title>
    <link href="https://anshenzheng.github.io/2017/02/15/Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>https://anshenzheng.github.io/2017/02/15/Spring-AOP的实现机制/</id>
    <published>2017-02-15T05:14:22.000Z</published>
    <updated>2017-07-30T10:13:01.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>AOP（Aspect Orient Programming），一般称为面向切面编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。静态代理是编译期实现，动态代理是运行期实现，可想而知前者拥有更好的性能。本文主要介绍Spring AOP的两种代理实现机制，JDK动态代理和CGLIB动态代理。</p><a id="more"></a><p>静态代理是编译阶段生成AOP代理类，也就是说生成的字节码就织入了增强后的AOP对象；动态代理则不会修改字节码，而是在内存中临时生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。</p><p>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的，诸如private的方法也是不可以作为切面的。</p><p>我们分别通过实例来研究AOP的具体实现。</p><h4 id="直接使用Spring-AOP"><a href="#直接使用Spring-AOP" class="headerlink" title="直接使用Spring AOP"></a>直接使用Spring AOP</h4><p>首先定义需要切入的接口和实现。为了简单起见，定义一个<code>Speakable</code>接口和一个具体的实现类，只有两个方法<code>sayHi()</code>和<code>sayBye()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Speakable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayBye</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSpring</span> <span class="keyword">implements</span> <span class="title">Speakable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Hi!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Bye!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们希望实现一个记录<code>sayHi()</code>和<code>sayBye()</code>执行时间的功能。</p><p>定义一个<code>MethodMonitor</code>类用来记录Method执行时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodMonitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodMonitor</span><span class="params">(String method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        System.out.println(<span class="string">"begin monitor.."</span>);</span><br><span class="line">        <span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">"end monitor.."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Method: "</span> + method + <span class="string">", execution time: "</span> + elapsedTime + <span class="string">" milliseconds."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>光有这个类还是不够的，希望有个静态方法用起来更顺手，像这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MonitorSession.begin();</span><br><span class="line">doWork();</span><br><span class="line">MonitorSession.end();</span><br></pre></td></tr></table></figure><p>说干就干，定义一个<code>MonitorSession</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MethodMonitor&gt; monitorThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(String method)</span> </span>&#123;</span><br><span class="line">        MethodMonitor logger = <span class="keyword">new</span> MethodMonitor(method);</span><br><span class="line">        monitorThreadLocal.set(logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodMonitor logger = monitorThreadLocal.get();</span><br><span class="line">        logger.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>万事具备，接下来只需要我们做好切面的编码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution (* com.deanwangpro.aop.service.Speakable.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MonitorSession.begin(pjp.getSignature().getName());</span><br><span class="line">        pjp.proceed();</span><br><span class="line">        MonitorSession.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何使用？我用了spring boot，写一个启动函数吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Speakable personSpring;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner</span><span class="params">(ApplicationContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            <span class="comment">// spring aop</span></span><br><span class="line">            System.out.println(<span class="string">"******** spring aop ******** "</span>);</span><br><span class="line">            personSpring.sayHi();</span><br><span class="line">            personSpring.sayBye();</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">******** jdk dynamic proxy ******** </span><br><span class="line">begin monitor..</span><br><span class="line">Hi!!</span><br><span class="line">end monitor..</span><br><span class="line">Method: sayHi, execution time: 32 milliseconds.</span><br><span class="line">begin monitor..</span><br><span class="line">Bye!!</span><br><span class="line">end monitor..</span><br><span class="line">Method: sayBye, execution time: 22 milliseconds.</span><br></pre></td></tr></table></figure></p><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>刚刚的例子其实内部实现机制就是JDK动态代理，因为Person实现了一个接口。</p><p>为了不和第一个例子冲突，我们再定义一个<code>Person</code>来实现<code>Speakable</code>, 这个实现是不带Spring Annotation的，所以他不会被Spring托管。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span> <span class="keyword">implements</span> <span class="title">Speakable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Hi!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Bye!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重头戏来了，我们需要利用<code>InvocationHandler</code>实现一个代理，让它去包含<code>Person</code>这个对象。那么再运行期实际上是执行这个代理的方法，然后代理再去执行真正的方法。所以我们得以在执行真正方法的前后做一些手脚。JDK动态代理是利用反射实现，直接看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object arg0, Method arg1, Object[] arg2)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MonitorSession.begin(arg1.getName());</span><br><span class="line">        Object obj = arg1.invoke(target, arg2);</span><br><span class="line">        MonitorSession.end();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>getProxy</code>可以得到这个代理对象，<code>invoke</code>就是具体的执行方法，可以看到我们在执行每个真正的方法前后都加了Monitor。</p><p>我实现了一个工厂类来获取Person代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Speakable <span class="title">newJdkProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代理PersonImpl</span></span><br><span class="line">        DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(<span class="keyword">new</span> PersonImpl());</span><br><span class="line">        Speakable proxy = dynamicProxy.getProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// jdk dynamic proxy</span></span><br><span class="line">System.out.println(<span class="string">"******** jdk dynamic proxy ******** "</span>);</span><br><span class="line">Speakable jdkProxy = PersonProxyFactory.newJdkProxy();</span><br><span class="line">jdkProxy.sayHi();</span><br><span class="line">jdkProxy.sayBye();</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">******** jdk dynamic proxy ******** </span><br><span class="line">begin monitor..</span><br><span class="line">Hi!!</span><br><span class="line">end monitor..</span><br><span class="line">Method: sayHi, execution time: 32 milliseconds.</span><br><span class="line">begin monitor..</span><br><span class="line">Bye!!</span><br><span class="line">end monitor..</span><br><span class="line">Method: sayBye, execution time: 22 milliseconds.</span><br></pre></td></tr></table></figure><h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><p>我们再新建一个<code>Person</code>来，这次不实现任何接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Hi!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Bye!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Spring识别到所代理的类没有实现Interface，那么就会使用CGLib来创建动态代理，原理实际上成为所代理类的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CGLibProxy instance = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CGLibProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CGLibProxy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span>  &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method arg1, Object[] arg2,</span></span></span><br><span class="line"><span class="function"><span class="params">                            MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MonitorSession.begin(arg1.getName());</span><br><span class="line">        Object obj = arg3.invokeSuper(arg0, arg2);</span><br><span class="line">        MonitorSession.end();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的通过<code>getProxy</code>可以得到这个代理对象，<code>intercept</code>就是具体的执行方法，可以看到我们在执行每个真正的方法前后都加了Monitor。</p><p>在工厂类中增加获得Person代理类的方法,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">newCglibProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CGLibProxy cglibProxy = CGLibProxy.getInstance();</span><br><span class="line">    Person proxy = cglibProxy.getProxy(Person.class);</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cglib dynamic proxy</span></span><br><span class="line">System.out.println(<span class="string">"******** cglib proxy ******** "</span>);</span><br><span class="line">Person cglibProxy = PersonProxyFactory.newCglibProxy();</span><br><span class="line">cglibProxy.sayHi();</span><br><span class="line">cglibProxy.sayBye();</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin monitor..</span><br><span class="line">Hi!!</span><br><span class="line">end monitor..</span><br><span class="line">Method: sayHi, execution time: 53 milliseconds.</span><br><span class="line">begin monitor..</span><br><span class="line">Bye!!</span><br><span class="line">end monitor..</span><br><span class="line">Method: sayBye, execution time: 14 milliseconds.</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>对比JDK动态代理和CGLib代理，在实际使用中发现CGLib在创建代理对象时所花费的时间却比JDK动态代理要长，实测数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method: newJdkProxy, execution time: 5 milliseconds.</span><br><span class="line">Method: newCglibProxy, execution time: 18 milliseconds.</span><br></pre></td></tr></table></figure><p>所以CGLib更适合代理不需要频繁实例化的类。</p><p>在具体方法执行效率方面，理应是不通过反射的CGlib更快一些，然后测试结果并非如此，还需要高手指教。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JDK</span><br><span class="line">Method: sayHi, execution time: 32 milliseconds.</span><br><span class="line">CGLib</span><br><span class="line">Method: sayHi, execution time: 53 milliseconds.</span><br></pre></td></tr></table></figure><p>以上code都可以通过<a href="https://github.com/deanwong/aop-study" target="_blank" rel="noopener">Github</a>中获取。</p><p>转自<a href="http://www.deanwangpro.com/2017/02/08/aop-in-java/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Spring AOP的实现机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AOP（Aspect Orient Programming），一般称为面向切面编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。静态代理是编译期实现，动态代理是运行期实现，可想而知前者拥有更好的性能。本文主要介绍Spring AOP的两种代理实现机制，JDK动态代理和CGLIB动态代理。&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="https://anshenzheng.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="https://anshenzheng.github.io/tags/Java/"/>
    
      <category term="aop" scheme="https://anshenzheng.github.io/tags/aop/"/>
    
      <category term="Spring" scheme="https://anshenzheng.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO</title>
    <link href="https://anshenzheng.github.io/2016/07/16/Java-NIO/"/>
    <id>https://anshenzheng.github.io/2016/07/16/Java-NIO/</id>
    <published>2016-07-16T14:51:43.000Z</published>
    <updated>2017-07-27T15:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="NIO模型原理"><a href="#NIO模型原理" class="headerlink" title="NIO模型原理"></a>NIO模型原理</h3><p>Channel: Channel是一个在TCP连接之间的抽象，一个TCP链接可以对应多个管道，而不是以前的方式只有一个通信信道，减少了TCP连接次数。</p><p>UDP：采用相同方式，也是抽象为管道。</p><p>通过selector(选择器)，相当于管家，管理所有的IO事件(Connection/accept，客户端服务端的读写等)。</p><h4 id="Selector管理IO事件"><a href="#Selector管理IO事件" class="headerlink" title="Selector管理IO事件"></a>Selector管理IO事件</h4><p>当IO事件注册给selector时，selector会给它们分配key值(可以简单理解为事件的标签), 当I/O事件完成后，会通过key值找到相应的管道，然后通过管道发送数据和接受数据等操作.</p><h4 id="数据缓冲区："><a href="#数据缓冲区：" class="headerlink" title="数据缓冲区："></a>数据缓冲区：</h4><p>通过bytebuffer， 提供了很多读写方法</p><ul><li>put</li><li>get</li></ul><h4 id="服务端：ServerSocketChannel"><a href="#服务端：ServerSocketChannel" class="headerlink" title="服务端：ServerSocketChannel"></a>服务端：ServerSocketChannel</h4><h4 id="客户端：SocketChannel"><a href="#客户端：SocketChannel" class="headerlink" title="客户端：SocketChannel"></a>客户端：SocketChannel</h4><h4 id="选择器：Selector"><a href="#选择器：Selector" class="headerlink" title="选择器：Selector"></a>选择器：Selector</h4><p>打开选择器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure></p><h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><p>可以通过它来判断IO事件是否已经就绪，通过以下代码获得:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey keys = Selector.selectedKeys();</span><br></pre></td></tr></table></figure></p><p>状态获取：<br>key.isAccptable() - 是否可以接受客户端的连接<br>key.isConnectionable() - 是否可以连接服务器<br>key.isReadable() - 是否可读<br>key.isWriteable() - 是否可写</p><h4 id="如何注册"><a href="#如何注册" class="headerlink" title="如何注册"></a>如何注册</h4><p>channel.regist(Selector, SelectionKey.OP_Write);<br>channel.regist(Selector, SelectionKey.OP_Read);<br>channel.regist(Selector, SelectionKey.OP_Connect);<br>channel.regist(Selector, SelectionKey.OP_Accept);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;NIO模型原理&quot;&gt;&lt;a href=&quot;#NIO模型原理&quot; class=&quot;headerlink&quot; title=&quot;NIO模型原理&quot;&gt;&lt;/a&gt;NIO模型原理&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JMS</title>
    <link href="https://anshenzheng.github.io/2016/06/08/JMS/"/>
    <id>https://anshenzheng.github.io/2016/06/08/JMS/</id>
    <published>2016-06-08T04:39:57.000Z</published>
    <updated>2017-08-01T13:02:21.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="什么是JMS"><a href="#什么是JMS" class="headerlink" title="什么是JMS"></a>什么是JMS</h3><ul><li>JMS是Java Message Servie的缩写</li><li>它是一个用于在不同的客户端之间传递消息的Java消息的中间件应用接口</li><li>它是处理生产者消费者问题的一种实现</li><li>它也是一种消息标准，允许应用组件在J2EE平台创建，发送，接受和读取消息</li></ul><p>JMS和JDBC很像，Java只是提供了一个访问JMS服务器以及进行消息处理的API标准，它完全独立于中间件消息服务器，就像JDBC独立于Oracle/Mysql之类的数据库一样。</p><h3 id="JMS的消息模型"><a href="#JMS的消息模型" class="headerlink" title="JMS的消息模型"></a>JMS的消息模型</h3><ul><li><p>P2P 端到端模型<br>P2P模型的target是队列(Queue), 消息首先发送到队列中, 之后在从队列中发送给监听队列的客户端中。一个队列可以连接多个消息发送方和多个消息接收方, 但是一个消息只能发送给一个接受者。如果有多个接收方都在监听队列中的消息, 那么JMS消息的发送将基于FCFS(First Come, First Server)原则。如果没有接收方监听队列, 那么消息将一直保存在队列中, 直到有接收方连接到队列。<br><img src="https://github.com/Anshenzheng/ImageStore/blob/master/JMS%20P2P.PNG?raw=true" alt=""></p></li><li><p>Pub/Sub 发布订阅模型<br>Pub/Sub模型中，一个消息可以从一个应用发送给多个接收者, 此时的target是topic。消息首先被发送至topic中, 之后会发送给所有订阅了该topic的接收者。<br><img src="https://github.com/Anshenzheng/ImageStore/blob/master/JMS%20P2S.PNG?raw=true" alt=""></p></li></ul><h3 id="JMS的使用"><a href="#JMS的使用" class="headerlink" title="JMS的使用"></a>JMS的使用</h3><h4 id="JMS-API模块"><a href="#JMS-API模块" class="headerlink" title="JMS API模块"></a>JMS API模块</h4><p><img src="https://github.com/Anshenzheng/ImageStore/blob/master/JMS%20API%20Modules.PNG?raw=true" alt=""></p><ul><li><p>Administered Objects<br>Administered Objects是预配置的JMS对象, 它有系统管理员创建, 用于管理Connection Factory和Destination。</p></li><li><p>Connection Factories<br>客户端通过Connection Factory创建通JMS服务器之间的连接。JMS客户端会在JNDI命名空间中查找并创建连接, 通target之间建立连接之后, 就可以发送或者接收消息。</p></li></ul><p>代码示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueueConnectionFactory factory = (QueueConnectionFactory)initialCxt.lookup(<span class="string">"primaryQCF"</span>);</span><br><span class="line">Queue puchaseQueue = (Queue)initialCxt.lookup(<span class="string">"Purchase_Queue"</span>);</span><br><span class="line">Queue returnQueue = (Queue)initialCtx.lookup(<span class="string">"Return_Queue"</span>);</span><br></pre></td></tr></table></figure></p><ul><li>Destination<br>Destination指明消息发送的目标, 或者消息的来源, 可以是Queue也可以是Topic。</li></ul><p>创建Queue代码示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueueSession session = con.createQueueSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">Queue queue = (Queue)ctx.lookup(<span class="string">"myQueue"</span>);</span><br><span class="line">QueueReceiver receiver = session.createReceiver(queue);</span><br></pre></td></tr></table></figure></p><p>创建Topic代码示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TopicSession session = con.createTopicSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">Topic topic = (Topic)ctx.lookup(<span class="string">"myTopic"</span>);</span><br><span class="line">TopicSubscriber receiver = session.createSubscriber(topic);</span><br></pre></td></tr></table></figure></p><ul><li><p>Connection<br>Connection用于连接JMS服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建连接</span></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure></li><li><p>Sessions<br>Session是一个单线程上下文对象, 用于创建生产者或者消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Session</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>,Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure></li><li><p>Message Producer<br>消息生产者由Session创建，用于发送消息到Destination。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageProducer producer = session.createProducer(dest);</span><br><span class="line">MessageProducer producer2 = session.createProducer(queue);</span><br><span class="line">MessageProducer producer3 = session.createProducer(topic);</span><br><span class="line"></span><br><span class="line">producer.send(message);</span><br></pre></td></tr></table></figure></li><li><p>Message Consumers<br>消息消费者也是由Session创建, 用于从Destination接收消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageConsummer consummer = session.createConsummer(dest);</span><br><span class="line">MessageConsummer consummer2 = session.createConsummer(queue);</span><br><span class="line">MessageConsummer consummer3 = session.createConsummer(topic);</span><br><span class="line"></span><br><span class="line">consummer.send(message);</span><br></pre></td></tr></table></figure></li><li><p>Message Listeners<br>消息监听器是默认的事件处理器, 它是MessageListener接口的实现, 该接口中包含的onMessage方法用于处理消息发送成功之后的处理逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Listener myListener = <span class="keyword">new</span> Listener();</span><br><span class="line">Consummer.setMessageListener(myListener);</span><br></pre></td></tr></table></figure></li></ul><h3 id="JMS消息结构"><a href="#JMS消息结构" class="headerlink" title="JMS消息结构"></a>JMS消息结构</h3><p>JMS客户端通过JMS消息同JMS服务器进行交互, JMS消息包括以下3部分:</p><h4 id="Message-Header-消息头"><a href="#Message-Header-消息头" class="headerlink" title="Message Header 消息头"></a>Message Header 消息头</h4><p>消息头中预定义了一些字段用于JMS客户端和JMS服务器之间的识别和消息传送。</p><p>消息头：</p><ul><li>JMSDestination</li><li>JMSDeliveryMode</li><li>JMSMessageID</li><li>JMSTimestamp</li><li>JMSCorrelationID</li><li>JMSReplyTo</li><li>JMSRedelivered</li><li>JMSType</li><li>JMSExpiration</li><li>JMSPriority</li></ul><h4 id="Message-Property-消息属性"><a href="#Message-Property-消息属性" class="headerlink" title="Message Property 消息属性"></a>Message Property 消息属性</h4><p>消息属性可以由用户自定义，主要是提供给应用程序使用, 可以用于消息过滤。<br>JMS API提供的也有一些标准的属性信息。</p><h4 id="Message-Body-消息体"><a href="#Message-Body-消息体" class="headerlink" title="Message Body 消息体"></a>Message Body 消息体</h4><p>JMS提供的消息体有以下5种：</p><ul><li><p>Text Message<br>javax.jms.TextMessage</p></li><li><p>Object Message<br>javax.jms.ObjectMessage</p></li><li><p>Bytes Message<br>javax.jms.BytesMessage</p></li><li><p>Stream Message<br>javax.jms.streamMessage</p></li><li><p>Map Message<br>javax.jms.MapMessage</p></li></ul><h4 id="JMS的使用示例"><a href="#JMS的使用示例" class="headerlink" title="JMS的使用示例"></a>JMS的使用示例</h4><p><a href="http://www.cnblogs.com/chenpi/p/5565618.html" target="_blank" rel="noopener">Tomcat + JNDI + ActiveMQ P2P</a></p><p><a href="http://www.cnblogs.com/chenpi/p/5566983.html" target="_blank" rel="noopener">Tomcat + JNDI + ActiveMQ Pub/Sub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;什么是JMS&quot;&gt;&lt;a href=&quot;#什么是JMS&quot; class=&quot;headerlink&quot; title=&quot;什么是JMS&quot;&gt;&lt;/a&gt;什么是JMS&lt;/h3&gt;&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="中间件" scheme="https://anshenzheng.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="JMS" scheme="https://anshenzheng.github.io/tags/JMS/"/>
    
      <category term="中间件" scheme="https://anshenzheng.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>应用服务器集群几种基本实现方式</title>
    <link href="https://anshenzheng.github.io/2015/07/29/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>https://anshenzheng.github.io/2015/07/29/应用服务器集群实现方式/</id>
    <published>2015-07-29T06:18:35.000Z</published>
    <updated>2017-07-29T08:22:52.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>负载均衡是网站必不可少的基础技术手段，不但可以实现网站的伸缩性，还可以改善网站的可用性。<br><img src="/images/负载均衡0.png" alt=""><br>负载均衡的实现技术也有多种多样，从硬件到软件，从商业产品到开源软件，多不胜数，主要实现负载均衡的基础技术有以下几种：</p><h3 id="HTTP重定向负载均衡"><a href="#HTTP重定向负载均衡" class="headerlink" title="HTTP重定向负载均衡"></a>HTTP重定向负载均衡</h3><p>HTTP重定向服务器时一台普通的应用服务器，唯一的功能就是根据用户的HTTP请求计算出一台真实的Web服务器地址，并将该Web服务器地址写入HTTP重定向响应中(响应状态码302)返回给用户浏览器，然后浏览器自动重新请求实际的物理服务器IP地址，从而完成访问。</p><p>这种实现方案优点是比较简单，缺点是浏览器需要两次请求服务器才能完成一次访问，性能比较差。重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限。而且使用HTTP302响应吗重定向有可能使搜索引擎判断为SEO作弊，降低搜索排名。</p><h3 id="DNS域名解析负载均衡"><a href="#DNS域名解析负载均衡" class="headerlink" title="DNS域名解析负载均衡"></a>DNS域名解析负载均衡</h3><p>这是利用DNS处理域名解析请求的同时进行负载均衡处理的一种方案。在DNS服务器中对指定域名配置多个ip地址，每次域名解析请求都会根据负载均衡算法计算出一个不同的IP地址，这样配置的多个服务器就构成一个集群，并且可以实现负载均衡。</p><p>DNS域名解析负载均衡的优点是将负载均衡的工作转交给DNS，省掉了网站管理维护负载均衡服务器的麻烦，同时许多DNS还支持基于地理位置的域名解析，即会将域名解析成距离用户地理最近的一个服务器地址，这样可以加速用户访问速度，改善性能。<br>DNS域名解析负载均衡的缺点是目前的DNS是多级解析，每一级DNS都可能缓存，当下线了某台服务器后，即使修改了DNS中的记录，要使其生效也需要很长时间，这段时间，DNS依然会将域名解析道已经下线的服务器，从而导致用户访问失败。而且DNS负载均衡的控制权在域名服务商那里，网站无法对其做更多的改善和更强大的管理。</p><p>实际上，很多大型网站总是部分使用DNS域名解析，利用域名解析作为第一级负载均衡手段，即域名解析得到的一组服务器并不是实际提供Web服务的物理服务器，而是同样提供负载均衡服务的内部服务器，这组内部负载均衡服务器再进行负载均衡，将请求分发到真实的Web服务器上。</p><h3 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h3><p>反向代理服务器位于服务器端，正好是负载均衡服务器的位置，所以大多数反向代理服务器同时提供负载均衡的功能，管理一组Web服务器，将请求根据负载均衡算法转发到不同的Web服务器上，Web服务器处理完成的响应请求也需要通过反向代理服务器返回给用户。由于Web服务器不直接对外提供访问，因此Web服务器不需要使用外部IP地址，而反向代理则需要配置双网卡和内部外部两套IP地址。</p><p>反向代理负载均衡的优点是负载均衡和反向代理服务器功能集成在一起，部署简单。缺点时反向代理服务器是所有请求和响应的中转站，性能可能会成为瓶颈。</p><h3 id="IP负载均衡"><a href="#IP负载均衡" class="headerlink" title="IP负载均衡"></a>IP负载均衡</h3><p>IP负载均衡的原理是在网络层通过修改请求目标地址进行负载均衡。用户请求数据包达到负载均衡服务器之后，负载均衡服务器在操作系统内核进程获取网络数据包，根据负载均衡算法计算得到真实的Web服务器IP地址，然后将数据目的IP地址修改为真实的Web服务器地址，不需要通过用户进程处理。真实Web应用服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器再将数据包源地址修改为自身的IP地址发送给用户浏览器。</p><p>这里的关键在于真实物理Web服务器响应数据如何返回给负载均衡服务器。一种方案是负载均衡服务器修改目的IP地址的同时修改源地址，将数据包源地址设为自身的IP地址，即源地址转换(SNAT), 这样Web服务器的响应会再回到负载均衡服务器；另一种方案是负载均衡服务器同时作为真实物理服务器集群的网关服务器，这样所有的响应数据都会达到负载均衡服务器。</p><p>IP负载均衡在内核进程完成数据分发，比反向代理负载均衡有更好的处理性能。但是由于所有请求响应都需要经过负载均衡服务器，集群的最大响应数据吞吐量不得不受制于负载均衡服务器网卡带宽。对于提供下载服务或者是视频服务等需要传输大量数据的网站而言，难以满足需求。</p><h3 id="数据链路层负载均衡"><a href="#数据链路层负载均衡" class="headerlink" title="数据链路层负载均衡"></a>数据链路层负载均衡</h3><p>数据链路层负载均衡是指在通信协议的数据链路层修改MAC地址进行负载均衡。<br>负载均衡数据分发过程中不修改IP地址，之修改MAC地址，通过配置真实物理服务器集群所有机器虚拟IP和负载均衡服务器IP地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器IP地址和数据请求的目的IP一致，不需要经过负载均衡服务器进行地址转换，就可以把响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载均衡方式又称为直接路由方式。</p><p>这种方式是目前大型网站使用最广的一种负载均衡手段， Linux平台上最好的链路层负载均衡开源产品时LVS (Linux Virtual Server).</p><p>参考：<br>《大型网站技术架构》 李智慧 著</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;负载均衡是网站必不可少的基础技术手段，不但可以实现网站的伸缩性，还可以改善网站的可用性。&lt;br&gt;&lt;img src=&quot;/images/负载均衡0.png&quot; alt=&quot;&quot;&gt;&lt;br
      
    
    </summary>
    
    
  </entry>
  
</feed>
