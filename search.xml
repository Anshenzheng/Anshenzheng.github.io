<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTPS Basic]]></title>
    <url>%2F2018%2F10%2F23%2FHTTPS%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[目前网上有特别多的关于HTTPS认证的文章，但是很多讲的都比较笼统，要么也只介绍了其中一部分。本文旨在提供一个简单全面的关于认证的介绍，方便广大读者在短时间内能对HTTPS有一个全面深层次的认识和理解。 本文会从一下几方面讲解HTTPS认证的相关内容： 12345678910111213141516171. 基础概念 1.1 加密 Vs Hash 1.2 对称加密 Vs 非对称加密3. SSL/TLS4. CA 4.1 CA Sample 4.2 CA Apply 4.3 CA Validation5. HTTPS 单向认证6. HTTPS 双向认证7. 应用 7.1 Keytool 7.2 keystore Vs trustsotre 7.3 Configure HTTPS in Tomcat8. 其它 8.1 Base64 8.2 SSH 基础概念加密 Vs Hash加密技术是利用技术手段和算法，把重要的数据加密后转化为乱码，传送到目的地后再通过相同或不同的手段还原。加密前的内容成为明文，加密后的内容成为密文。Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。 对称加密 Vs 非对称加密对称加密是采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。 流行的对称加密算法有DES, Triple-DES, RC2 和 RC4. 非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 TLS/SSLSSL是Netscape公司发明的一种用于WEB安全传输协议。随着时间推移由于Netscape失去市场份额，它将SSL的维护工作移交给了因特网工程任务组(IETF),后被重新命名为TLS。 SSL协议功能 数据传输保密性 数据传输完整性 通信双方身份认证 证书由一个可信任的组织验证和签发的识别信息,是包含公钥、订阅人相关信息以及证书颁发者数字签名的数字文件，也就是一个让我们可以交换、存储和使用的公钥的壳。 证书链在大多数情况下，仅仅有最终实体证书是无法进行有效性验证的，所以在实践中，服务器需要提供证书链才能一步步最终验证到可信根证书。如果根CA被吊销，所有使用CA签发出来的证书的网站都会无法正常访问。Baseline Requirements限制所有的根证书密钥必须离线保存，只能由人手动执行命令，直接由根证书签发最终实体证书是不允许的。与根证书不同，二级CA一般都是在线的，而且使用自动化系统签发证书。 服务器一次只能提供一条证书链 信赖方信赖方为了能够验证证书，必须收集新人的所有根CA证书。大多数操作系统都提供一个根证书库，从而在一开始启动的时候就能建立信任。几乎所有的软件开发者都重用了底层操作系统提供的根证书库，唯一例外的是Mozilla，为了保证不同平台的兼容性，它维护了自己的根证书库。 AppleApple维护的根证书库主要是给IOS和OSX平台使用。 Chrome在LINUX上, Chrome只用Mozilla的根证书库，除此之外都是依赖操作系统的证书库。 MicrosoftMicrosoft维护的根证书库主要是给Windows桌面版、服务器以及移动手机平台使用。 MozillaMozilla为自己的产品维护了一个公开透明的根证书库，并且大部分Linux版本都使用了Mozilla的根证书库。 所有的根证书库都要求CA通过专门为证书颁发机构设计的独立审计。 标准X.509是一种公钥基础设施的国际标准，最初是为了支持X.500而设计的。X.500是电子目录服务的标准，但未广泛使用过。X.509经过PKIX工作组改造适合在互联网上使用。 PKIX工作组成立于1995年秋天，目标是简历支持基于X.509公钥基础设施的互联网标准。PKIX工作组产出的最重要的文档是RFC5280，它描述了证书的格式、可信任证书链的建立，以及证书吊销列表(CRL)的格式。PKIX在2013年10月结束了自己的使命。 CABCA/Browser论坛是由证书颁发机构、浏览器厂商以及其他有相关权益的团体自发形成的组织，目标是建立和推行证书颁发和处理的标准。 一开始，CAB论坛是为了确定增强型证书(EV)的颁发标准而创建的，在2007年EV证书诞生了。CAB最开始只是一些松散的组织，但是随后他们改变了关注焦点并且在2012年改组。同年，CAB论坛发布了《公共可信证书的颁发和管理的基本要求》，即Baseline Requirements for the Issuance and Management of Publicly-Trusted Certificates, 简称Baseline Requirements keytoolkeystore Vs trustsotreKeyStore和TrustStore是JSSE中使用的两种文件。都是使用Java的keytool来管理。他们的不同主要在于用途和相应通途决定的内容的不同。KeyStore用于存储自己的密码，私钥和证书。TrustStore用于存储来自他人的公钥和证书。 HTTPS 单向认证 HTTPS 双向认证 其它SSH从客户端来看，SSH服务主要提供两种级别的安全验证： 基于口令只要知道服务器的SSH连接账号和口令，就能通过客户端登录到远程主机，而连接过程中所有传输的数据都是加密的。 基于密钥这种方式需要先建立一个密钥对，然后把公钥放在需要访问的目标服务器上，再把私钥放到客户端或者对应的客户端服务器上。如果想要连接到公用密钥的SSH服务器，客户端SSH软件或者客户端服务器就会向服务器发出请求，请求用连接的用户密钥进行安全验证。服务器收到请求后，会先寻找事先安装好的公钥，然后和客户端发送过来的密钥进行比较，如果匹配，就用公钥加密“质询”信息并发送给客户端。客户端收到“质询”信息后用私钥解密，再把它发送给服务器。执行ssh命令生成密钥对生成私钥id_rsa和公钥id_rsa.pub 1ssh-keygen -t rsa 应用场景 Hadoop集群间免密通讯 SFTP Git免密提交 代码中使用添加信任所有证书(不做处理)123456789101112131415161718192021222324252627282930import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import javax.net.ssl.X509TrustManager;/** * 信任所有证书 * @author hp * */public class AllTrustManager implements X509TrustManager &#123; @Override public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException &#123; // TODO Auto-generated method stub &#125; @Override public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException &#123; // TODO Auto-generated method stub &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; // TODO Auto-generated method stub return null; &#125;&#125; 使用HttpsURLConnection发送POST请求（默认443端口） import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.URL; import java.security.KeyManagementException; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.security.UnrecoverableKeyException; import java.security.cert.CertificateException; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.KeyManagerFactory; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSocketFactory; import javax.net.ssl.TrustManager; public class HttpsRequest { //测试url private final static String URL_TEST="https://www.baidu.com"; //客户端证书路径 private final static String PATH="c://xxxx"; //证书密码 private final static String psw="123456"; /** * 发送POST请求 * @param agrs * @return * @throws IOException * @throws KeyManagementException * @throws KeyStoreException * @throws NoSuchAlgorithmException * @throws CertificateException * @throws UnrecoverableKeyException */ public String doPost(String agrs) throws IOException, KeyManagementException, KeyStoreException, NoSuchAlgorithmException, CertificateException, UnrecoverableKeyException{ //导入客户端证书 KeyStore ks=KeyStore.getInstance("pkcs12"); FileInputStream instream = new FileInputStream(new File(PATH)); ks.load(instream, psw.toCharArray()); KeyManagerFactory kmf=KeyManagerFactory.getInstance("SunX509"); kmf.init(ks, psw.toCharArray()); //添加信任证书 TrustManager[] tm={new AllTrustManager()};//AllTrustManager()为信任所有证书 SSLContext ctx=SSLContext.getInstance("SSL");//创建ssl上下文 //初始化 ；参数1为null，则不上传客户端证书（通常情况都是如此）； ctx.init(kmf.getKeyManagers(), tm, new SecureRandom()); //ctx.init(kmf.getKeyManagers(), null, new SecureRandom());//验证系统默认证书 //ctx.init(kmf.getKeyManagers(), TrustManager[] tm, new SecureRandom());//导出服务端证书，然后按照keymanager一样实现trustmanager SSLSocketFactory sf=ctx.getSocketFactory(); URL _url=new URL(URL_TEST); HttpsURLConnection conn=(HttpsURLConnection) _url.openConnection(); conn.setRequestMethod("POST");//设定请求方法 conn.setConnectTimeout(20000); conn.setReadTimeout(20000); conn.setDoInput(true);//打开输入流 conn.setDoOutput(true);//打开输出流写入写出参数必需 conn.setSSLSocketFactory(sf);//添加ssl参数 //输出参数 PrintWriter pw=new PrintWriter(conn.getOutputStream()); pw.write(agrs); pw.flush(); //获取输入流 BufferedReader br=new BufferedReader(new InputStreamReader(conn.getInputStream())); StringBuffer result=new StringBuffer(); String s=br.readLine(); while(s!=null){ result.append(s); s=br.readLine(); } pw.close(); br.close(); return result.toString(); } }]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>keytool</tag>
        <tag>keystore</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[没有admin权限如何免安装使用Node和NPM]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%B2%A1%E6%9C%89admin%E6%9D%83%E9%99%90%E5%A6%82%E4%BD%95%E5%85%8D%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8Node%E5%92%8CNPM%2F</url>
    <content type="text"><![CDATA[此教程只针对于在windows系统上没有admin权限和软件安装权限，但是又希望能像安装版一样使用Node和NPM的用户。 步骤一： 下载压缩版node访问https://nodejs.org/en/download, 根据自己的系统，选择下载32位或者64位的免安装压缩包版node。解压压缩包，将node.exe文件拷贝到自己想要存放node的路径，比如C:\annan\nodejs\。 步骤二： 下载压缩版NPM访问https://github.com/npm/npm/releases, 下载最新发布的稳定版NPM。解压压缩包，并将解压出的主文件目录更名为npm.打开步骤一中存放node.exe的文件目录, 新建文件夹命名为node_modules, 之后将整个npm文件夹拷贝到node_modules文件夹中。 步骤三： 拷贝npm.cmd文件到node.exe所在目录打开步骤二中node_modules\npm\bin目录，找到npm.cmd文件， 并将之拷贝到node.exe文件所在的目录。 步骤四： 配置环境变量打开cmd命令行工具， 执行指令“rundll32 sysdm.cpl,EditEnvironmentVariables”之后，环境变量面板会自动跳出，之后将node.exe和npm.cmd所在路径配置到环境变量path中，这样我们就可以随意使用node和npm命令了。 步骤五： 验证设置打开命令行工具， 输入node -v 之后输入npm -v，就可以看到我们已经配置安装好了最新版本的node和npm.12345C:\Users\annan&gt;node -vv8.10.0C:\Users\annan&gt;npm -v5.7.1]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular]]></title>
    <url>%2F2018%2F01%2F20%2FAngular%2F</url>
    <content type="text"><![CDATA[概述Angular 是由Google开发与维护的一个开发跨平台应用程序的框架，适用于手机与桌面，是一个比较完善的前端MVC框架，包含了模版，双向数据绑定，路由，服务，过滤器，依赖注入等功能。 Angular提供的功能 动态HTML 强大的表单系统 强大的视图引擎 快速的页面渲染 灵活的路由 HTTP服务 视图封装 环境搭建1. 基于Angular Quickstart1.1 克隆官方标准项目1git clone https://github.com/angular/quickstart ng4-quickstart 1.2 安装依赖12cd ng4-quickstartnpm i 1.3 启动应用1npm start 2. 基于Angular CLI1.1 安装Angular CLI1npm install -g @angular/cli 1.2 检测是否安装成功1ng --version 1.3 创建新项目1ng new PROJECT-NAME 若在后面添加参数 –routing, 则会在app目录中创建对应的路由相关配置文件。 1.4 启动本地服务器12cd PROJECT-NAMEng serve ng server命令会启动开发服务器，监听文件的变化，文件修改后会自动重新构建应用。 Welcome to app如下图： 1.5 Angular启动过程功过项目根目录下的angular-cli.json文件，可以发现启动js文件位于src/main.ts中，页面的入口文件位于src/index.html. 核心概念核心概念总览 模块 指令 服务 Angular 路由路由是Angular导航的关键。在设置路由之前，我们需要在app/index.html中添加路由说明1&lt;base href="/"&gt; 路由模块已经从Angular中分离出来，所以使用时需要导入：1import &#123; RouterModule, Routes&#125; from '@angular/router'; 现在写一个简单的路由配置：12345678910111213141516171819// app/modules/app-routing.module.tsimport &#123;NgModule&#125; from '@angular/core';import &#123;Routes, RouterModule&#125; from '@angular/router';import &#123;DemoComponentComponent&#125; from '../demo/demo-component/demo-component.component';const routes: Routes = [ &#123; path: 'demoComponent', component: DemoComponentComponent &#125;,..., &#123; path: '**', component: DemoComponentComponent &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule&#123;&#125; **为通配path 不能以”/“开头在特性模块中，应使用RouterModule.forChild 定义好路由模块，还需将其注册到主模块中：1234567891011// app.module.tsimport &#123;AppComponent&#125; from './app.component';import &#123;AppRoutingModule&#125; from './modules/app-routing.module';@NgModule(&#123; ..., imports:[..., AppRoutingModule], providers:[], bootstrap: [AppComponent]&#125;)export class AppModule&#123;&#125; 有了路由导航之后， 还需要一个容器来显示对应的组件内容：1&lt;router-outlet&gt;&lt;/router-outlet&gt; Angular 依赖注入组件中注入服务：配置已创建的服务12345@NgModule(&#123; // ... providers: [MemberService]&#125;)export class AppModule &#123; &#125; 导入已创建的服务1import &#123; MemberService &#125; from '../member.service'; 使用构造方式注入服务1234export class MembersComponent implements OnInit &#123; // ... constructor(private memberService: MemberService) &#123; &#125;&#125; 服务使用示例创建服务 12345678910111213import &#123; Injectable &#125; from '@angular/core';import &#123; Http &#125; from '@angular/http';@Injectable()export class MemberService &#123; constructor(private http: Http) &#123; &#125; getMembers() &#123; return this.http .get(`https://api.github.com/orgs/angular/members?page=1&amp;per_page=5`) .map(res =&gt; res.json()) &#125;&#125; 配置服务12345678import &#123; MemberService &#125; from "./member.service";@NgModule(&#123; // ... providers:[MemberService], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 使用服务12345678910111213141516// ...import &#123; MemberService &#125; from "./member.service";@Component(&#123;...&#125;)export class MembersComponent implements OnInit &#123; members: Member[];constructor(private memberService: MemberService) &#123; &#125;ngOnInit() &#123; this.memberService.getMembers() .subscribe(data =&gt; &#123; if (data) this.members = data; &#125;); &#125;&#125; 组件应用示例 1 应用示例 2 代码示例 组件通讯 组件生命周期 数据绑定， 响应式编程和管道 表单处理Angular中有两种表单Template Driven Forms: 模版驱动表单Reactive Forms: 响应式表单 模板驱动表单导入表单模块12345678import &#123;FormsModule&#125; from '@angular/forms';//...@NgModule(&#123; imports: [BrowserModule, FormsModule], declarations: [AppComponent, UserComponent], bootstrap: [AppComponent]&#125;)export class AppModule&#123;&#125; 表单使用示例1234567891011121314151617181920212223@Component(&#123; selector: 'sl-user', template:' ... &lt;div *ngIf=showSkills&gt; &lt;h3&gt;My Skills&lt;/h3&gt; ... &lt;form (submit)="addSkill(skill.value)"&gt; &lt;label&gt;Add new Skills&lt;/label&gt; &lt;input type="text" #skill&gt; &lt;/form&gt; &lt;/div&gt; ... '&#125;)export class UserComponent&#123; addSkill(skill: string)&#123; let skillStr = skill.trim(); if(this.skills.indexOf(skillStr) === -1)&#123; this.skills.push(skillStr); &#125; &#125;&#125; 与服务端通讯使用http协议和WebSocket协议与服务器进行通讯。 导入入Http模块1234567import &#123;HttpModule&#125; from '@angular/http';@NgModule(&#123;imports: [BrowserModule, FormsModule, HttpModule],declarations: [AppComponent, UserComponent],bootstrap: [AppComponent]&#125;)export class AppModule 使用Http服务步骤 从@angular/http模块中导入Http类 使用DI注入http服务 调用http的get()/post()等方法设置请求地址并发送HTTP请求 调用Response对象的json()方法，将response转换为JSON对象 把请求结果赋值给对应的属性Http服务使用示例1234567891011121314151617181920212223242526272829303132333435363738import &#123; Component, OnInit &#125; from '@angular/core';import &#123; Http &#125; from '@angular/http'; // (1)import 'rxjs/add/operator/map'; // (2)interface Member &#123; id: string; login: string; avatar_url: string;&#125;@Component(&#123; selector: 'sl-members', template: ` &lt;h3&gt;Angular Orgs Members&lt;/h3&gt; &lt;ul *ngIf="members"&gt; &lt;li *ngFor="let member of members;"&gt; &lt;p&gt; &lt;img [src]="member.avatar_url" width="48" height="48"/&gt; ID：&lt;span&gt;&#123;&#123;member.id&#125;&#125;&lt;/span&gt; Name: &lt;span&gt;&#123;&#123;member.login&#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; `&#125;)export class MembersComponent implements OnInit &#123; members: Member[]; constructor(private http: Http) &#123; &#125; // (3) ngOnInit() &#123; this.http.get(`https://api.github.com/orgs/angular/members?page=1&amp;per_page=5`) // (4) .map(res =&gt; res.json()) // (5) .subscribe(data =&gt; &#123; if (data) this.members = data; // (6) &#125;); &#125;&#125; 内置指令 ngIf ngModel 自定义指令12345678910import &#123;Directive, ElementRef, Renderer&#125; from '@angular/core';@Directive(&#123; selector: '[highlight]'&#125;)export class HighlightDirective&#123; constructor(el: ElementRef, render: Renderer)&#123; render.setElementStyle(el.nativeElement, 'backgroundColor', 'yellow'); &#125;&#125; 构建和部署编译Typescript写成的项目，将其构建为最终可发布的js代码，并发布到nodejs服务器上去。 完整示例AppModule12345678910111213141516171819202122232425import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms';import &#123; HttpModule &#125; from '@angular/http';import &#123; RouterModule, Routes &#125; from '@angular/router';import &#123; AppComponent &#125; from './app.component';import &#123; UserComponent &#125; from './user.component';import &#123; MembersComponent &#125; from './members.component';import &#123; MemberService &#125; from "./member.service";export const ROUTES: Routes = [ &#123; path: '', pathMatch: 'full', redirectTo: 'user' &#125;, &#123; path: 'user', component: UserComponent &#125;, &#123; path: 'members', component: MembersComponent &#125;];@NgModule(&#123; imports: [BrowserModule, FormsModule, HttpModule, RouterModule.forRoot(ROUTES)], declarations: [AppComponent, UserComponent, MembersComponent], providers: [MemberService], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; AppComponent12345678910111213141516import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'my-app', template: ` &lt;div class="app"&gt; &lt;h1&gt;欢迎来到Angular的世界&lt;/h1&gt; &lt;nav&gt; &lt;a routerLink="/user"&gt;我的&lt;/a&gt; &lt;a routerLink="/members"&gt;Angular成员&lt;/a&gt; &lt;/nav&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;/div&gt; `,&#125;)export class AppComponent &#123; &#125; UserComponent1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import &#123; Component &#125; from '@angular/core';interface Address &#123; province: string; city: string;&#125;@Component(&#123; selector: 'sl-user', template: ` &lt;h2&gt;大家好，我是&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;p&gt;我来自&lt;strong&gt;&#123;&#123;address.province&#125;&#125;&lt;/strong&gt;省, &lt;strong&gt;&#123;&#123;address.city&#125;&#125;&lt;/strong&gt;市 &lt;/p&gt; &lt;button (click)="toggleSkills()"&gt; &#123;&#123; showSkills ? "隐藏技能" : "显示技能" &#125;&#125; &lt;/button&gt; &lt;div *ngIf="showSkills"&gt; &lt;h3&gt;我的技能&lt;/h3&gt; &lt;ul&gt; &lt;li *ngFor="let skill of skills"&gt; &#123;&#123;skill&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;form (submit)="addSkill(skill.value)"&gt; &lt;label&gt;添加技能&lt;/label&gt; &lt;input type="text" #skill&gt; &lt;/form&gt; &lt;/div&gt; `&#125;)export class UserComponent &#123; name: string; address: Address; showSkills: boolean; skills: string[]; constructor() &#123; this.name = 'Semlinker'; this.address = &#123; province: '福建', city: '厦门' &#125;; this.showSkills = true; this.skills = ['AngularJS 1.x', 'Angular 2.x', 'Angular 4.x']; &#125; toggleSkills() &#123; this.showSkills = !this.showSkills; &#125; addSkill(skill: string) &#123; let skillStr = skill.trim(); if (this.skills.indexOf(skillStr) === -1) &#123; this.skills.push(skillStr); &#125; &#125;&#125; MembersComponent123456789101112131415161718192021222324252627282930313233343536373839import &#123; Component, OnInit &#125; from '@angular/core';import &#123; Http &#125; from '@angular/http';import 'rxjs/add/operator/map';import &#123; MemberService &#125; from "./member.service";interface Member &#123; id: string; login: string; avatar_url: string;&#125;@Component(&#123; selector: 'sl-members', template: ` &lt;h3&gt;Angular Orgs Members&lt;/h3&gt; &lt;ul *ngIf="members"&gt; &lt;li *ngFor="let member of members;"&gt; &lt;p&gt; &lt;img [src]="member.avatar_url" width="48" height="48"/&gt; ID：&lt;span&gt;&#123;&#123;member.id&#125;&#125;&lt;/span&gt; Name: &lt;span&gt;&#123;&#123;member.login&#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; `&#125;)export class MembersComponent implements OnInit &#123; members: Member[]; constructor(private memberService: MemberService) &#123; &#125; ngOnInit() &#123; this.memberService.getMembers() .subscribe(data =&gt; &#123; if (data) this.members = data; &#125;); &#125;&#125; MemberService12345678910111213import &#123; Injectable &#125; from '@angular/core';import &#123; Http &#125; from '@angular/http';@Injectable()export class MemberService &#123; constructor(private http: Http) &#123; &#125; getMembers() &#123; return this.http .get(`https://api.github.com/orgs/angular/members?page=1&amp;per_page=5`) .map(res =&gt; res.json()) &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>前端</tag>
        <tag>“框架”</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IBM UrbanCode Deploy]]></title>
    <url>%2F2017%2F09%2F29%2FIBM-UrbanCode-Deploy%2F</url>
    <content type="text"><![CDATA[企业应用部署面临的挑战分析述企业应用(Enterprise Application)是指运行在操作系统和中间件之上，实现特定业务逻辑的软件发布包和业务数据。企业应用部署(Enterprise Application Deployment)是把企业应用部署在一台或多台计算机的操作系统或中间件之上，从而提供一个可供测试、培训和生产的运行环境。 企业应用部署是软件持续交付（Continuous Delivery）的重要环节，特别是所交付的企业应用部署架构复杂（比如多机）、部署环境多（比如开发、测试、生产环境）和部署频率高（比如每周一次）时，如何提高企业应用部署的效率和质量，对企业信息化是否能快速满足业务需求的快速变化至关重要。 然而，当前的企业应用部署在方法体系上缺乏完善的管理信息模型，在工具上采用手工编写和执行部署脚本。这种传统的应用部署方式会导致部署效率不高，对部署过程缺乏管控，对部署结果缺乏审计。 IBM UrbanCode Deploy 概述IBM UrbanCode Deploy（简称 UCD）是 IBM 的应用自动化部署工具。该工具基于一个完善的应用部署自动化管理信息模型，提供可视化的部署逻辑设计手段，并通过远程代理技术，实现对复杂应用在不同环境下的自动化部署。该工具功能组件参考下图： 图 1. IBM UCD 功能组件图 UCD 不仅仅是一个实现应用部署自动化的工具，还是一个服务于系统工程师（负责部署环境的系统管理）、发布工程师（负责应用的部署逻辑设计）、部署工程师（负责执行应用部署）和质量工程师（负责应用部署前和部署后的质量审计）等多个角色的管理平台。 该平台所提供的功能点包括如下：1、环境管理：实现对被部署机器以及所提供资源（比如数据库、中间件等）的管理。2、组件管理：实现对应用部署组件（比如企业应用的安装包、数据更新脚本等）的维护，以及组件部署逻辑（比如如何安装在 Tomcat 上安装一个发布包）的可视化设计。3、应用管理：实现企业应用的维护、关联组件以及如何编排多个组件的部署逻辑来完成整个应用的部署逻辑。4、执行管理：实现应用部署环境的定义、资源的映射以及应用部署的执行。5、仪表盘：实现对应用部署的统计分析，包括成功、失败统计分析以及部署时长统计分析等。6、部署工件管理：实现对部署文件的集中存储，版本比对等功能。7、插件管理：实现对可重用部署步骤的管理，并可自定义可重用的部署步骤。8、系统管理：实现用户、组、角色、团队的管理，定义完善的权限策略。 IBM UrbanCode Deploy 系统架构作为一个企业应用部署自动化管理平台，UCD 基于如下逻辑技术架构，确保支持复杂环境（比如有部署环境和服务器之间有防火墙）下的应用部署。下面将分别介绍 UCD 的每个技术组件。 图 2. IBM UCD 系统架构图 应用服务器基于 Tomcat 的 JavaEE 应用，是 UCD 的核心并提供主要的功能。 CodeStationUCD 自带的发布文件存储库，提供发布文件的版本管理功能。 关系数据库存储 UCD 的管理信息，比如用户信息、部署逻辑信息等。 Browser（浏览器）UCD 用户的主要使用界面，提供应用部署自动化的日常管理界面。 Client（客户端）UCD 提供的命令行，用户可通过命令行来访问 UCD。 Agent（代理）安装在被部署机器上，提供远程执行部署逻辑的能力。 中继服务器（Relay Server）当被部署的环境和 UCD 应用服务器之间有防火墙时，中继服务器作为一个中转实现代理和应用服务器之间的通信。 IBM UrbanCode Deploy 信息模型为了实现对多应用、多环境的自动化部署，UCD 定义了完善的信息模型。信息模型就是描述了特定领域的信息类型以及相互关系，是对某个特定领域的抽象，也是开发特定领域软件工具的基础。下图是 UCD 所包含的应用部署自动化管理信息模型。 图 3. IBM UCD 信息模型 本文将以 JPetStore 应用为例解释上图的信息模型。JPetStore 是一个基于 Struts 和 iBATIS 技术的网上宠物店应用，该应用的中间件采用 Tomcat，数据库采用 MySQL。 在上图中，表示 A 和 B 之间是包含关系，也就是说如果 A 类型实例不存在，那 A 类型实例所包含的 B 类型实例也不会存在，”*”表示一个 A 类型实例可包含 0 个或多个 B 类型实例。表示 C 和 D 是关联关系，也是说一个 C 类型实例可以关联 0 个或多个 D 类型实例。 应用（Application）针对特定用户，并解决特定业务问题的软件包和数据，比如 JPetStore 就是一个应用。 组件（Component）具有独立功能，并可被复用的一组文件。比如 JPetStore 应用中，可涉及实现网上宠物店应用逻辑的 JPetStore_APP 组件、提供宠物照片的 JPetStore_WEB 组件以及定义数据库的 JPetStore_DB 组件。 版本（Version）一个组件所包含的部署文件的多个版本。比如 JPetStore_APP 组件的 JPetStore.war 文件可以有 1.0，1.1 等多个版本。 版本状态（Version Status）组件版本所对应的质量状态。比如 JPetStore_APP 的 1.1 版本已经通过系统集成测试，则该组件版本的状态可设置为“已通过系统集成测试”。 快照（Snapshot）一个应用的特定版本，该应用版本关联一组组件版本。比如 JPetStore 应用的 1.1 版本关联了 JPetStore_APP 组件的 1.1 版本、JPetStore_WEB 组件的 1.0 版本以及 JPetStore_DB 组件的 1.0 版本。步骤（Step）：可重用的特定部署任务，比如在把 JPetStore_APP 组件部署到 Tomcat 应用时，“启动 Tomcat 服务器”就是一个步骤。 插件（ Plugin）包含一组相关步骤的容器。比如针对 Tomcat 应用的部署，常用的步骤包括“启动 Tomcat 服务器”、“卸载 WAR 包”、“安装 WAR 包”等。这些步骤放在“Tomcat”这个插件容器中。 组件流程（Component Process）针对特定组件所定义的操作步骤序列，该操作步骤序列引用 Plugin 中定义的步骤。比如针对 JPetStore_APP 组件，可定义安装该组件的“Install APP”流程、卸载该组件的“Uninstall APP”流程。 应用流程（Application Process）对一个完整应用所定义的操作步骤，比如为部署 JPetStore 应用所定义的应用部署流程“Install Process”，该流程引用了 JPetStore_APP 组件流程“Install APP ”、JPetStore_DB 组件流程“Install DB”和 JPetStore_WEB 组件流程“Install WEB ”。 代理（Agent）部署在一台计算机上的进程，该进程实现部署逻辑在该计算机上的执行。比如 JPetStore 将在两台计算机上部署，则定义的 agent 是“agent101”和“agent102”。 代理池（Agent Pool）对代理按特定分类标准而进行的分类，比如按代理的用途分可创建“测试服务器”和“生产服务器”代理池，按操作系统类型分可创建“Windows 服务器”和“LINUX 服务器”。一个代理池可关联多个代理，而一个代理也可以被多个代理池关联。 资源（Resource）在特定代理机上所提供的能力，比如 Tomcat 服务资源，数据库资源，一个代理可包含多个资源。 环境（Environment）针对特定应用以及特定用途所映射的一组资源。比如针对 JPetStore 应用可定义集成测试环境 SIT（System Integration Test）和用户验收测试环境 UAT（User Acceptance Test）。 审批流程（Approval Process）针对特定环境所定义的审批流程，比如把应用部署到 UAT 环境时，需要通过质量保证工程师的审批，则可定义一个审批流程。 环境门（Environment Gate）是指应用在特定环境部署时所需要部署的组件版本必须要满足的条件。比如当应用要部署到 UAT 环境时，所部署的组件版本必须处于“已通过系统集成测试”状态。此外，UCD 作为一个企业级应用部署自动化平台，有不同用户访问该工具，因此需要定义完善的权限管理模型。下图是 UCD 是提供的权限信息模型。 图 4. IBM UCD 权限信息模型 用户（User）访问 UCD 的一个注册用户。 角色（Role）具有一组特定权限的用户类型。比如针对 JPetStore 应用的部署管理，可定义“系统工程师”、“发布工程师”、“部署工程师”和“质量工程师”等角色。 团队（Team）是对 UCD 中所定义的应用部署对象（比如应用、组件等）进行的分类，比如为了确保只有特定人员能访问 JPetStore 应用相关的信息，可创建 JPetStore 团队，然后分配该团队中不同角色所对应的用户。 许可（Permission）是指能进行特定操作的能力，比如“创建资源”就是一个许可。 安全类型（Security Type）一组相关的许可。 组（Group）一组相关的用户，便于快速分配特定角色所对应的用户。 IBM 应用部署自动化工具 UrbanCode Deploy 使用模型UCD 提供了丰富的应用部署管理功能，不同的用户可以通过浏览器页面完成与应用部署相关的工作。下面以 JPetStore 应用为例，介绍如何利用 UCD 把 JPetStore 应用自动部署到系统集成测试环境（SIT）和用户验收测试环境（UAT）的流程。 JPetStore 应用部署准备流程定义 JPetStore 应用部署资源系统工程师通过 UCD 建立代理以及资源。在应用比较多、资源比较复杂时，建议按应用、环境、代理、资源对资源进行层次组织。如下图定义了 JPetStore 应用所对应的资源。 图 5. 定义应用部署资源 定义 JPetStore 应用和组件发布工程师通过 UCD 建立应用以及组件，并定义组件流程和应用流程。下图是针对 JPetStore 应用的 JPetStore_APP 组件所定义的组件流程。UCD 提供了丰富的 Plugin，利用 Plugin 中包含的步骤可通过可视化方式快速定义部署逻辑。 图 6. 定义组件部署流程 定义 JPetStore 部署组件和资源的映射在执行应用部署前，应用发布工程师需要确定在不同的环境下每个组件所对应的资源。比如在下图中，JPetStore 在部署到 SIT 环境时，将把 JPetStore_APP、JPetStore_DB 和 JPetStore_WEB 组件都部署到 Agent101 提供的资源上。 图 7. 定义部署组件和资源的映射 JPetStore 应用部署执行流程该流程完成把 JPetStore_APP 组件的一个新版本部署到 SIT 环境和 UAT 环境的流程。 导入 JPetStore_APP 组件的新版本应用发布工程师在获知有新的组件版本时，执行版本导入（Import Versions）操作，把最新的组件版本导入到 UCD 中。下图是把JPetStore_APP 组件的 1.3 版本导入到 UCD 中，并可比较不同版本之间的差异。 图 8. 导入组件的新版本 执行 JPetStore 应用在 SIT 环境上的部署部署工程师选定 JPetStore 应用，执行在 SIT 环境上部署，并选择部署组件的最新版本。如下图： 图 9. 执行应用部署 查看 JPetStore 应用在 SIT 环境上部署的组件版本在完成部署后，部署工程师可获得在 SIT 环境上所部署的版本，以及通过“View Request”查看详尽的部署日志。 图 10. 查看部署结果 创建 JPetStore 应用的快照为了能快速把已经成功部署到 SIT 环境的应用版本部署到其它环境上或者实现应用部署活动的回退，可创建一个应用的快照。下图是基于 SIT 环境上部署的版本创建一个应用快照“JPetStore_1.3”，该快照关联 JPetStore_APP 1.3 版本、JPetStore_WEB 1.0 版本和 JPetStore_DB 1.1 版本。 图 11. 创建应用快照 设置 JPetStore 应用组件的状态如果 JPetStore 应用在系统集成环境已成功部署，并通过系统集成测试，质量工程师则把组件的状态设置为”组件经过 SIT 测试”，对 JPetStore-WEB 1.0 和 JPetStore-DB 1.1 的版本状态也按此设置。这样确保这些组件版本能部署到用户验收测试环境下。图 12. 设置应用组件状态 把 JPetStore 的 1.3 版本部署到 UAT 环境部署工程师选择 JPetStore 应用，执行在 UAT 环境上部署，并选择“JPetStore 1.3”快照，确保部署在 UAT 环境的版本和部署在 SIT 环境下的版本是一致的。 图 13. 把应用快照部署到环境 查看 JPetStore 在 SIT 和 UAT 环境下的部署版本质量工程师可通过如下界面获得应用在不同环境下所部署的版本，并可比较不同环境下部署版本之间的差异。下图显示的是 JPetStore 应用在 SIT 和 UAT 环境下部署的版本。 图 14. 查看环境中部署的组件版本 统计 JPetStore 应用的部署情况所有人员可通过 UCD 提供的报告能力对部署情况进行统计。比如，下图是对 JPetStore 应用的部署情况的统计报告。 图 15. 查看应用部署统计信息 小结针对企业应用在多环境、高频率下的部署，IBM UrbanCode 基于完善的应用部署管理信息模型，可视化的应用部署管理界面，帮助企业提高应用部署的自动化水平、部署管控和审计水平。 转自：利用 IBM UrbanCode Deploy 实现企业应用部署自动化]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UDeploy</tag>
        <tag>CI</tag>
        <tag>Deploy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cassandra 概要介绍]]></title>
    <url>%2F2017%2F08%2F01%2FCassandra%20%E6%A6%82%E8%A6%81%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Cassandra只一个开源分布式NoSQL数据库，具有高度可扩展性和高可用性，可用于管理大量的结构化和非结构化数据, 主要特性如下: 持续可用性, 易于管理大量服务器和不会有单点故障 支持非常方便的列索引, 高性能的日志结构数据更新，强大的非规格化和物化视图以及缓存功能 采用去中心化的架构所有的节点都是平等的, Cassandra自动化地在环或者说数据库集群的所有节点之间进行数据分发开发人员或管理人员无法也没必要通过程序来控制数据分发，因为集群里所有几点的数据分区对用户是透明的 提供了内建的可定制的replication机制, 在整个集群的节点上保存冗余的数据副本 具有线性扩展性，也就是说可以简单的在线添加新节点从而增加集群的处理能力例如，如果每两个节点每秒处理100,000个事务, 4个几点就能每秒处理200,000个事务。 Cassandra基本数据模型Cluster 集群Cassandra数据分布在不同的机器集群节点上。 KeyspaceKeyspace相当于关系数据库中的数据库，是一系列Column Family的集合。创建keyspace时需指定如下几种属性： replication_factor 复制因子集群中接收相同数据副本的计算机数。 stategry class 副本放置策略 SimpleStrategry 简单策略为集群指定简单的复制因子 旧网络拓扑策略单独为每个数据中心设置复制因子 网络拓扑策略单独为每个数据中心设置复制因子 创建语法 12CREATE KEYSPACE Keyspace nameWITH replication=&#123;'class': 'SimpleStrategry', 'replication_factor': 3&#125; Keysspace示意图 Column FamilyColumn Family相当于关系数据库中的表，是一系列Column的集合，在该集合中，每个Column都会有一个与之相关联的键：12345678910Authors = &#123; "1234": &#123; "name": "Harry", "age": 18 &#125;, "5678":&#123; "name": "Lucy", "age": 19 &#125;&#125; ColumnColumn是Cassandra所支持的最基础的数据模型，可以包含一系列的键值对：12345&#123; "name": "Author Name", "value": "Harry", "timestamp": 123456789&#125; Super ColumnSuper Column是包含了一系列Column:1234567&#123; "name": "Cassandra Introduction", "value": &#123; "author": &#123;"name": "Author Name", "value": "Harry", "timestamp": "123456789"&#125;, "publisher": &#123;"name":"Publisher", "value": "China Press", "timestamp": 223154878&#125; &#125;&#125; Cassandra官方文档不建议过多使用Super Column Primary Key &amp; Composite Key &amp; Partition Key &amp; Clustering Key主键, 定义Cassandra数据表时指定，可以指定一个字段也可以指定多个字段。1234create table user(user_id text PRIMARY KEY,user_name text); 组合主键 - Composite Key, 下例中key_one和key_two组成Composite Key.123456create table sampe( key_one text, key_two text, data text, PRIMARY KEY(key_one, key_two)); Composite key中的第一组成为Partition Key, 后面各组称为Clustering Key. Partition Key用于决定Cassandra会使用集群中哪个结点来记录该数据， 每个PartitionKey对应着一个Parition.Clustering Key用来在Partition内部排序。 在CQL语句中， WHERE等子句所标识的条件只能使用在Primary Key中所使用的列。 COL - Cassandra Query LanguageJava中Cassandra数据库的操作123456789101112131415161718192021222324252627Cluster cluster = null;try&#123; //创建连接到Cassandra客户端 cluster = Cluster.builder() .addContactPoint("127.0.0.1") .build(); //创建用户会话 Session session = cluster.connect(); //执行CQL语句 ResultSet rs = session.execute("select release_version from system.local"); //从返回结果中取出第一条结构 Row row = rs.one(); System.out.println(row.getString("release_version")); //创建并使用keyspace String query = "CREATE KEYSPACE tp WITH replication = &#123;'class':'SimpleStrategry', 'replication_factor':3&#125;"; session.execute(query); session.execute("USE tp"); &#125;finally&#123; if(cluster != null)&#123; cluster.close(); &#125;&#125; Cassandra内部存储结构Cassandra写入数据之前，需要先记录日志(CommitLog), 然后数据开始写入到ColumnFamily对应的Memtable中,Memtable是一种按照Key排序数据的内存结构，在满足一定条件时，再把Memtable中的数据批量持久化到磁盘上，存储在SSTable中。 Cassandra数据信息分为3类： data目录用户存储真正的数据文件，是SSTable文件, 可以指定多个目录 commitlog目录用于存储未写入SSTable中的数据 cache目录用户存储系统中的缓存数据，在服务重启时，从此目录加载缓存数据。 参考：cassandra教程]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Cassandra</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式应用架构学习（一）]]></title>
    <url>%2F2017%2F07%2F15%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[分布式应用架构的演变随着互联网的快速发展和演进, 不断变化的商业环境所带来的业务需求, 使得单一应用架构越来越复杂, 越来越难以支撑业务体系的发展。 因此系统拆分就成了不可避免的事情, 由此演变为垂直应用架构体系。 垂直应用架构解决了单一应用所面临的扩容问题, 流量可以分散到各个子系统中, 且系统体积可控, 一定程度上降低了开发人员之间协同和维护的成本, 提升了开发效率。 当垂直应用越来越多达到一定规模时, 应用之间的相互交互和调用不可避免。否则不同系统之间存在着重叠的业务, 容易形成信息孤岛, 重复造轮子。此时相对核心的业务会被抽取出来, 作为单独的系统对外提供服务, 达成业务之间的相互复用,x系统也因此演变为分布式应用架构体系。 分布式应用架构所面临的首要问题, 便是如何实现应用之间的远程调用(RPC)。 RPCRPC全称是Remote Process Call, 即远程过程调用。RPC将原本本地调用转变为调用远端服务器上的方法, 给系统的处理能力和吞吐量带来了近似无限制提升的可能, 这是系统发展到一定阶段的必然改革, 也是分布式计算的基础。 RPC调用示意 (服务调用方调用服务提供方的服务) 基于HTTP协议的RPC 使用灵活 实现便捷 开放(国际标准) 天生支持异构平台之间的调用 基于TCP协议的RPC 效率高 实现复杂 跨平台难 业界主流RPC框架 Apache Thrift 由Facebook开发的高效支持多种编程语言的远程服务调用框架，采用接口描述语言定义创建，支持跨语言服务开发，可以与主流语言无缝衔接，采用二进制格式传输数据，对高并发，大数据量和多语言的环境比较有优势。 Avro-RPC Hadoop的子项目，支持丰富的数据结构类型，可定制性强，传输层和业务层分离，用户可以专注于业务逻辑的开发。 Hessian Caucho提供的给予binary-RPC实现的轻量级二进制远程通信框架，通过Servlet提供远程服务，可以将某个请求映射到Hessian服务。简单易用，面向接口编程，支持多语言，可与Spring集成。 gRPC Google开源的基于HTTP/2和ProtoBuf的通用RPC框架，支持多语言，基于http2的设计带来诸如双向流，流控，头部压缩，单TCP连接上的多复用请求等特性。 随着业务的发展, 服务调用者的规模发展到一定阶段, 对服务提供方的压力也日益增加, 因此服务需要进行扩容。而随着服务提供者的增加与业务的发展, 不同服务之间还需要进行分组, 以隔离不同业务, 避免相互影响, 此时, 服务的路由和负载均衡则成为必须要考虑的问题。 服务分组路由与负载均衡架构]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>架构</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML概论]]></title>
    <url>%2F2017%2F07%2F13%2FUML%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[在建筑业中, 建模是一项经过检验并被广泛接受的工程技术, 建立房屋和大厦的建筑模型, 能帮助用户得到实际建筑物的印象。在软件建模中也具有同样的作用, 建模提供了系统的蓝图。 建模是为了能够更好地理解正在开发的系统而建立的。通过建模有以下优点： 有助于按照实际情况或按照所需要的样式对系统进行可视化 能够规约系统的结构或行为 给出了指导构造系统的模板 对做出决策进行文档化 UML基本构成元素UML由图和元模型组成, 主要包括3个基本构造块： 事物事物是实体抽象化的最终结果, 是模型中的基本成员, UML中包括结构事物, 行为事物, 分组事物和注释事物 关系关系是将事物联系在一起的方式, UML中定义了4中关系, 即 依赖（两种事物之间的语义关系，其中一个事物发生变化会影响另一个事物的语义） 关联（描述一组对象之间连接的结构关系） 泛化（一种一般化到特殊化的关系） 实现（类之间的语义关系，其中的一个类制定了由另一个类保证执行的契约） 图(常见有以下10种图)用例图 描述系统需求 类图、对象图、包图 描述软件结构 组件图、部署图 描述硬件结构 状态图 描述对象静态状态的转换 活动图 描述对象动态活动的转换 序列图 描述多个对象之间在时间上的交互 协作图 描述多个对象之间在空间上的交互 下面的思维导图版的UML概要总结：]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Autonomy IDOL]]></title>
    <url>%2F2017%2F07%2F11%2FAutonomy%20IDOL%E6%A6%82%E8%A6%81%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[几年前在HP曾做过几个Autonomy IDOL(现在的HPE IDOL)相关的项目, IDOL的功能相当强大, 而我们只主要用到了的相关性查询, 情感分析, Logo识别, 人脸识别等功能, 有点杀鸡用牛刀的味道。 当时为了这个项目, 项目组还特意给我们申请了价值几百美金的Autonomy内部系列培训课程, 后来经过做项目过程中的层层实践和磨练, 一度成为项目组内部Autonomy专家, 安装、配置、接口使用，甚至于新功能的自我摸索和学习也不在话下。 但是Autonomy毕竟是一个大块头超昂贵的系统, 功能很强大, 卖的License自然也很贵, 所以一般可能只有某些大公司在使用, 大部分的中小公司是用不起的, 这也就决定了这门技术在需要的地方很吃香，但是很多地方都不需要。 几年过去了,由于之前的疏忽没有做过总结,大部分的知识都快忘光了,不过鉴于官网还是有比较详细的教程,这里只概要回顾一下: Autonomy提供了一种能够理解任何文件格式的全面软件基础架构解决方案。无论数据是文字还是语音，是结构化还是非结构化，采用何种创建和存储手段，Autonomy都可以进行处理。Autonomy的技术使企业应用系统独立于数据类型而运作，同时借助将手工操作自动化而提升了效率。 IDOL的工作流 IDOL中的一些常用组件：License ServerAutonomy的使用时基于license的，每一个license对应一个MAC地址。IDOL提供的大部分服务都必须有license才能正常工作。 ConnectorsConnectors是IDOL平台的一个核心组件，它可以灵活而精准的把不同格式(结构化，半结构化，上千种文件格式)不同来源的数据摄入到IDOL数据库中。常用的Connectors有如下几种： ODBC Connector通过配置可以直接连接所有支持ODBC的数据库，通过配置的SQL语句，直接从数据库中抽取数据。 File Connector可以从指定的本地或网络文件目录抽取文件内容到IDOL中。 Http Connector可以从指定的网站抓取内容。 CFS (Connector Framework Server)Connectors实现了如何从不同的数据源抽取数据，CFS则负责抽取的实施以及从抽取的文件中提取出元数据(metadata)和文件内容，并把它们加载的CFS的document中。这样IDOL Server可以直接搜索分析数据，而不需要再从原文件格式中提取数据。在数据进入IDOL数据库之前，还可以做一些增强操作，比如文字的情感分析， 文档归类， 概要生成等。增加了CFS这一层，是将所需要的数据提供了一个统一的入口，相当于从各种管道接来了水，放置在水池中，供IDOL来用。 IDOL ServerIDOL - 智能数据操作层(Intelligent Data Operating Layer)是Autonomy的核心，它可以收集来自各种连接器(Connectors)的数据, 并以其能够实现快速处理和检索的独特结构存储这些数据。在处理信息的时候，IDOL能够联系概念和语境来理解数据中的内容，可以对超过一千种不同格式的信息进行自动分析。 IDOL允许对数据源进行超过500多种操作，包括超链接、代理、摘要、分类、聚类、结构化信息抽取、档案建立、个性化信息提醒及检索。 Image Server用于图片内容的存储分析查询等，可以从图片中提取文字，通过图片训练还可以提供Logo识别，人脸识别等功能。 DAH (Distributed Action Handler)用于分布式查询和结果集的整理。 DIH (Distributed Action Handler)用于分布式索引, 将即将入库的文档分散为子集发送到集群中的各个server。 Query Manipulation Server查询管理。 Eduction Server为自己感兴趣的实体增加tag以便于查询和过滤。 Media Server分析处理视频数据，可以将视频分解为音频和图片，将音频转换为文字等。 IDOL Speech Server分析处理音频文件， 可以实现音频转换为文字，语音识别及语音搜索等功能。 IDOL中支持的功能： IDOL的应用架构 参考文档： https://my.vertica.com/documentation/idol/11-0/应用接口使用文档]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>Autonomy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见分布式全局唯一ID生成方案]]></title>
    <url>%2F2017%2F07%2F11%2F%E5%B8%B8%E8%A7%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[一般而言，几乎在任何系统中，我们都需要使用唯一的ID去识别以及操作应用中的对象，比如对用户管理而言需要用户ID，对订单管理而言需要订单ID。 在小的项目中，我们可以直接使用数据库的自增长特性来生成主键的ID，这样简单且易实现。但是在分库分表的分布式环境中，数据往往分布在不同的分片上，如果再通过数据库的自增长特性，势必会造成主键重复。 这就需要我们采用一些分布式全局唯一ID的生成方案，以下介绍几种常见的全局ID生成方案： Twitter的Snowflake算法(雪花算法)Twitter服务器上每秒钟都会有上百万条新的Twitter消息产生，每条消息都需要分配唯一的ID，而且为了方便客户端的排序，这些ID还需要一些大致的书序，为了解决这样一个问题，Twitter创建了Snowflake算法。 Snowflake算法核心Twitter生成的ID是64bits整数型，64位组成结构如下：标记位(1位，不可用)+时间戳(41位) + 机器ID(10位) + 序列号(12位) 标记位标记位一般为0， 不可以使用。 时间戳时间戳有41位，可以表示的数据为0 ~ 2^41，这里的时间戳的细度是毫秒级的，那么计算可知可以使用 2^41/(3652460601000) = 69.73年。具体生成代码如下: 12345uint64_t generateStamp()&#123; timeval tv; gettimeofday(&amp;tv, 0); return (uint64v_t)tv.tv_sec*1000 + (uint64v_t)tv.tv_usec/1000;&#125; 机器ID机器位有10位， 2^10 = 1024, 即可以支持1024台机器。 序列号位序列号分配有12位，2^12 = 4096, 即每毫秒支持产生4096个自增序列的ID。 UUID/GUIDUUID是一个由4个连字号(-)将32个字符长的字符串分割后生成的字符串,总共长36个字符长，它的生成主要基于以下几部分组合： 当前的日期和时间 时钟序列 全局唯一的机器识别号(如果有网卡就从网卡的MAC地址获得,如果没有就以其它方式获得) GUID(Globally Unique Identifier)是微软对UUID标准的实现,它是根据机器网卡的MAC地址再加上一个特定算法产生的二进制长度为128位的字符表示符。 UUID/GUID唯一的缺点是生成的结果比较长. Java中UUID生成代码12345678910public static void main(String[] args)&#123; String uuid = UUID.randomUUID().toString(); //去掉"-"的UUID String shortUUID = str.substring(0, 8) + str.substring(9, 13) + str.substring(14, 18) + str.substring(19, 23) + str.substring(24); System.out.println(uuid); System.out.println(shortUUID);&#125; MongoDB ObjectIDMongodb会为每条插入collection不包含”id”的记录自动生成一个24位字符长的objectId, 例如”4e7020cb7cac81af7136236b”. 这个24位的字符串实际上由一组16禁止的字符构成，每个字节两位十六禁止数字，总共用了12字节的存储空间。 根据官网中ObjectId规范的描述，它的组成结构如下: 时间戳(4bytes - 32bits)将前4位进行提取，然后按照十六进制转换成十进制，就可以得到一个时间 机器ID(3bytes - 24bits)接下来3个字节是所在主机的唯一表示符，一般是主机名的散列值。 进程ID - PID(2bytes - 16bits)pid是为了在同一机器下不同mongodb进程产生的objectID不冲突。 自增计数器 - INC(3bytes - 24bits)确保同一秒内产生的objectId也不会冲突。 参考文章：MongoDB深究之ObjectId]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>ID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的闭包]]></title>
    <url>%2F2017%2F07%2F10%2FJavascript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是闭包闭包(closure)是指在JavaScript中，将外部函数中的局部变量封闭起来的(内部)函数。(被封闭起来的变量与封闭它的函数具有相同的生命周期。) 示例如下： 123456789function func()&#123; var local = "local variable"; var inner = function()&#123; console.log(local); &#125; return inner;&#125; 示例中内部函数inner持有外部函数func的局部变量local，这样就构成了一个作用域(闭包)，通过该作用域我们可以访问及修改外部访问不到的内部变量。 闭包的作用管理私有变量和私有方法，将对变量的管理封装在安全环境之中。外层函数执行之后，它的局部变量本来应该全部销毁，但是由于闭包的存在，之后执行内部函数，通过它仍然可以访问到外层函数的变量。 123456789101112131415161718192021222324252627function func()&#123; var name = "Charlie"; return &#123; setName: function(new_name)&#123; name = new_name; &#125;, getName: function()&#123; return name; &#125; &#125;;&#125;var f = func();console.log(f.name);// 打印结果：// undefinedconsole.log(f.getName())// 打印结果：// Charlief.setName("Teddy");console.log(f.getName())// 打印结果：// Teddy]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cache相关的HTTP请求/响应头]]></title>
    <url>%2F2017%2F07%2F10%2FCache%E7%9B%B8%E5%85%B3%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[常见的HTTP请求/响应头有很多，以下介绍几种cache相关的： Pragma Cache-Control Expires Last-Modified Etag Pragma &amp; Cache-Control用于指定所有缓存机制在整个请求/响应链中必须服从的命令，如果知道该页面是否为缓存，不仅可以控制浏览器，还可以控制HTTP协议相关的缓存或者代理服务器。 Cache-Control请求字段优先级比较高，如果和其它一些相冲突的字段(比如Expires)同时出现，则Cache-Control会覆盖其它字段。Pragma的作用和Cache-Control类似，也是在HTTP头中包含一个特殊指令，使相关的服务器来遵守，Pragma:no-cache 和 Cache-Control:no-cache的作用是一样的。 浏览器中的强制刷新(Ctrl + F5)就是通过发起请求时加上请求头 Pragma:no-cache 和 Cache-Control:no-cache 实现的。 Expires通常格式为Expires:Sat,25Feb201712:22:17GMT,后面跟着日期和时间，超过这个时间值后，缓存内容将失效，也就是浏览器在发出请求之前会检查这个页面的字段，如果页面已经过期，就重新向服务器发起请求。 Last-Modified &amp; EtagLast-Modified一般用于表示一个服务器上的资源的最后修改时间，资源可以是静态或者是动态的。一般服务端在响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间，浏览器再次请求时在请求头中增加一个If-Modified-Since:Sat,25Feb201712:22:17GMT,询问当前缓存的页面是否是最新的，如果是最新的就返回304，告诉浏览器是最新的，服务器也不会传输新的数据。 Etag与Last-Modified功能类似，作用是让服务器给每个页面分配一个唯一的编号，然后通过编号来区分当前页面是否为最新。这种方式比Last-Modified更灵活，但是在后端的Web服务器有多台时就比较难处理，因为每个web服务器都要记住网站的所有资源，否则这个编号就没有意义了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>http</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的Prototype]]></title>
    <url>%2F2017%2F07%2F09%2FJavascript%E4%B8%AD%E7%9A%84Prototype%2F</url>
    <content type="text"><![CDATA[Prototype 是什么Javascript中，prototype是函数的一个属性，它本身是一个对象，而这个对象的构造函数指向函数本身。描述比较抽象，但是通过以下代码就很容易理解： 1234567function ff()&#123; return "this is function ff";&#125;console.log(ff.prototype.constructor == ff);// 打印结果：// true 由上也不难推出以下几个特殊对象的prototype： Array.prototype 是一个数组 String.prototype 是一个字符串 Object.prototype 是一个对象 需要注意的是，prototype属性只能用于函数，如果引用某个具体对象的prototye属性，则其为undefined。 例如： 12345678910111213141516171819function ff()&#123; return "this is function ff";&#125;console.log(ff.prototype); //打印结果：// [object Object]console.log(JSON.stringify(ff.prototype)); //打印结果:// &#123;&#125;console.log(new Object().prototype)//打印结果:// undefinedconsole.log(new ff().prototype)//打印结果:// 猜猜看是什么 :) Prototype 有什么用通过prototype可以为函数对象添加新的属性和方法, 所有通过 new 方法实现函数对象都会拥有新添加的方法和属性，相当于间接实现了继承。 例如： 123456789101112131415161718192021222324252627282930function animal(name)&#123; this.name = name; return this.name;&#125;animal.prototype.type = "animal";animal.prototype.sayHi = function()&#123; console.log("Hi, I am " + this.name);&#125;var cat = new animal('cat');var dog = new animal('dog');console.log(cat.type);console.log(cat.name);//打印结果:// animal// catconsole.log(dog.type);console.log(dog.name);//打印结果:// animal// dogcat.sayHi();//打印结果:// Hi, I am catdog.sayHi();//打印结果:// Hi, I am dog]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高数常用定理及使用]]></title>
    <url>%2F2017%2F07%2F08%2F%E9%AB%98%E6%95%B0%E5%B8%B8%E7%94%A8%E5%AE%9A%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[有界性定理要求：只用不证 最值定理要求：只用不证 介值定理要求：只用不证 积分中值定理 积分保号定理 零点定理要求：只用不证 费马定理要求：会用会证 罗尔定理要求：会用会证（最重要） 若题设条件“=”较多，则优先考虑使用罗尔定理。 拉格朗日定理 柯西中值定理要求：会用会证 泰勒定理（公式）要求：只用不证 带拉格朗日余项的公式 带佩亚诺余项的公式 麦克劳林公式（0点展开）]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高数</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中的日志文件]]></title>
    <url>%2F2017%2F07%2F07%2FMySQL%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[日志文件是数据库中非常重要的文件，可以用于操作查询，性能分析，事务保障以及数据恢复等。MySQL中的常见日志文件如下： 错误日志：Error Log错误日志记录了MySQL运行过程中所有较为严重的警告和错误信息，以及每次启动和关闭的详细信息。默认情况下，错误记录日志功能是关闭的，错误信息会被输出到标准错误输出stderr。我们可以在启动时开启1--log-error 选项开启错入日志功能。错误日志默认以hostname.err命名存放于数据目录下， 但是可以使用命令:1log-error[=file_name] 来修改存放的目录和文件名。 二进制日志：Binary Log &amp; Binary Log Index二进制日志是MySQL中最重要的日志之一，通过：1--log-bin[=file_name] 开启，MySQL会将所有修改数据库的Query(Query语句，执行时间，消耗资源，相关事务信息等)以二进制的形式记录于该日志文件。 以下是binlog的一些附加选项参数：–max_binlog_size - binlog的最大存储上限，当日志达到该上限时，会自动创建一个新日志。为了保证事务安全，MySQL不会将同一个事务分开记录到两个binlog中，故有时会超出最大上限。–binlog-do-db=db_name - 指明仅对db_name数据库记录binlog，忽略其它数据库执行的Query(db_name指当前正在连接的数据库)–binlog-ignore-db=db_name - 功能与–binlog-do-db相反 (db_name指当前正在连接的数据库)mysql-bin.index - 记录所有Binary Log的绝对路径，保证MySQL线程可以顺利的找到所需要的log文件。 更新日志: Update Log更新日志是MySQL在较老版本上使用的，功能与bin-log类似，以简单的文本格式记录，MySQL5.0之后不再支持。 查询日志: Query Log查询日志记录MySQL中所有的Query，可以通过1--log[=file_name] 来开启日志。由于记录了所有的Query，包括所有的Select语句，故体积比较大，开启后对性能影响也比较大。默认文件名为数据目录下的hostname.log. 慢查询日志：Slow Query Log用于记录执行时间较长的Query，通过1--log-slow-queries[=file_name] 开启，默认文件名为数据目录下的hostname-slow.log。慢查询日志采用简单文本格式，记录了语句执行的时刻，消耗的时间，执行的用户以及连接主机等相关的信息。MySQL还提供了mysqlslowdump工具程序专门用来分析慢查询日志，帮助数据库管理人员解决可能存在的性能问题。 InnoDB在线Redo日志：InnoDB REDO LogInnoDB是一个事务安全的存储引擎，其安全性主要是通过REDO日志和记录在表空间的UNDO信息来保证的。REDO日志中记录了InnoDB所做的所有物理变更和事务信息，默认存放于数据目录下，可以通过innodb_log_group_home_dir来更改日志存放位置，通过innodb_log_files_in_group设置日志数量。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP的实现机制]]></title>
    <url>%2F2017%2F02%2F15%2FSpring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[AOP（Aspect Orient Programming），一般称为面向切面编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。静态代理是编译期实现，动态代理是运行期实现，可想而知前者拥有更好的性能。本文主要介绍Spring AOP的两种代理实现机制，JDK动态代理和CGLIB动态代理。 静态代理是编译阶段生成AOP代理类，也就是说生成的字节码就织入了增强后的AOP对象；动态代理则不会修改字节码，而是在内存中临时生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。 Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。 如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的，诸如private的方法也是不可以作为切面的。 我们分别通过实例来研究AOP的具体实现。 直接使用Spring AOP首先定义需要切入的接口和实现。为了简单起见，定义一个Speakable接口和一个具体的实现类，只有两个方法sayHi()和sayBye()。 1234public interface Speakable &#123; void sayHi(); void sayBye();&#125; 1234567891011121314151617181920212223@Servicepublic class PersonSpring implements Speakable &#123; @Override public void sayHi() &#123; try &#123; Thread.currentThread().sleep(30); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; System.out.println("Hi!!"); &#125; @Override public void sayBye() &#123; try &#123; Thread.currentThread().sleep(10); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; System.out.println("Bye!!"); &#125;&#125; 接下来我们希望实现一个记录sayHi()和sayBye()执行时间的功能。 定义一个MethodMonitor类用来记录Method执行时间 1234567891011121314151617public class MethodMonitor &#123; private long start; private String method; public MethodMonitor(String method) &#123; this.method = method; System.out.println("begin monitor.."); this.start = System.currentTimeMillis(); &#125; public void log() &#123; long elapsedTime = System.currentTimeMillis() - start; System.out.println("end monitor.."); System.out.println("Method: " + method + ", execution time: " + elapsedTime + " milliseconds."); &#125;&#125; 光有这个类还是不够的，希望有个静态方法用起来更顺手，像这样 123MonitorSession.begin();doWork();MonitorSession.end(); 说干就干，定义一个MonitorSession 1234567891011121314public class MonitorSession &#123; private static ThreadLocal&lt;MethodMonitor&gt; monitorThreadLocal = new ThreadLocal&lt;&gt;(); public static void begin(String method) &#123; MethodMonitor logger = new MethodMonitor(method); monitorThreadLocal.set(logger); &#125; public static void end() &#123; MethodMonitor logger = monitorThreadLocal.get(); logger.log(); &#125;&#125; 万事具备，接下来只需要我们做好切面的编码， 12345678910111213141516@Aspect@Componentpublic class MonitorAdvice &#123; @Pointcut("execution (* com.deanwangpro.aop.service.Speakable.*(..))") public void pointcut() &#123; &#125; @Around("pointcut()") public void around(ProceedingJoinPoint pjp) throws Throwable &#123; MonitorSession.begin(pjp.getSignature().getName()); pjp.proceed(); MonitorSession.end(); &#125;&#125; 如何使用？我用了spring boot，写一个启动函数吧。 12345678910111213141516171819202122@SpringBootApplicationpublic class Application &#123; @Autowired private Speakable personSpring; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @Bean public CommandLineRunner commandLineRunner(ApplicationContext ctx) &#123; return args -&gt; &#123; // spring aop System.out.println("******** spring aop ******** "); personSpring.sayHi(); personSpring.sayBye(); System.exit(0); &#125;; &#125;&#125; 运行后输出:123456789******** jdk dynamic proxy ******** begin monitor..Hi!!end monitor..Method: sayHi, execution time: 32 milliseconds.begin monitor..Bye!!end monitor..Method: sayBye, execution time: 22 milliseconds. JDK动态代理刚刚的例子其实内部实现机制就是JDK动态代理，因为Person实现了一个接口。 为了不和第一个例子冲突，我们再定义一个Person来实现Speakable, 这个实现是不带Spring Annotation的，所以他不会被Spring托管。 12345678910111213141516171819202122public class PersonImpl implements Speakable &#123; @Override public void sayHi() &#123; try &#123; Thread.currentThread().sleep(30); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; System.out.println("Hi!!"); &#125; @Override public void sayBye() &#123; try &#123; Thread.currentThread().sleep(10); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; System.out.println("Bye!!"); &#125;&#125; 重头戏来了，我们需要利用InvocationHandler实现一个代理，让它去包含Person这个对象。那么再运行期实际上是执行这个代理的方法，然后代理再去执行真正的方法。所以我们得以在执行真正方法的前后做一些手脚。JDK动态代理是利用反射实现，直接看代码。 123456789101112131415161718192021222324252627public class DynamicProxy implements InvocationHandler &#123; private Object target; public DynamicProxy(Object object) &#123; this.target = object; &#125; @Override public Object invoke(Object arg0, Method arg1, Object[] arg2) throws Throwable &#123; MonitorSession.begin(arg1.getName()); Object obj = arg1.invoke(target, arg2); MonitorSession.end(); return obj; &#125; @SuppressWarnings("unchecked") public &lt;T&gt; T getProxy() &#123; return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this ); &#125;&#125; 通过getProxy可以得到这个代理对象，invoke就是具体的执行方法，可以看到我们在执行每个真正的方法前后都加了Monitor。 我实现了一个工厂类来获取Person代理对象 12345678910public class PersonProxyFactory &#123; public static Speakable newJdkProxy() &#123; // 代理PersonImpl DynamicProxy dynamicProxy = new DynamicProxy(new PersonImpl()); Speakable proxy = dynamicProxy.getProxy(); return proxy; &#125;&#125; 具体使用 12345 // jdk dynamic proxySystem.out.println("******** jdk dynamic proxy ******** ");Speakable jdkProxy = PersonProxyFactory.newJdkProxy();jdkProxy.sayHi();jdkProxy.sayBye(); 输出结果: 123456789******** jdk dynamic proxy ******** begin monitor..Hi!!end monitor..Method: sayHi, execution time: 32 milliseconds.begin monitor..Bye!!end monitor..Method: sayBye, execution time: 22 milliseconds. CGLib动态代理我们再新建一个Person来，这次不实现任何接口。 1234567891011121314151617181920public class Person &#123; public void sayHi() &#123; try &#123; Thread.currentThread().sleep(30); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; System.out.println("Hi!!"); &#125; public void sayBye() &#123; try &#123; Thread.currentThread().sleep(10); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; System.out.println("Bye!!"); &#125;&#125; 如果Spring识别到所代理的类没有实现Interface，那么就会使用CGLib来创建动态代理，原理实际上成为所代理类的子类。 1234567891011121314151617181920212223242526272829public class CGLibProxy implements MethodInterceptor &#123; private static CGLibProxy instance = new CGLibProxy(); private CGLibProxy() &#123; &#125; public static CGLibProxy getInstance() &#123; return instance; &#125; private Enhancer enhancer = new Enhancer(); @SuppressWarnings("unchecked") public &lt;T&gt; T getProxy(Class&lt;T&gt; clazz) &#123; enhancer.setSuperclass(clazz); enhancer.setCallback(this); return (T) enhancer.create(); &#125; @Override public Object intercept(Object arg0, Method arg1, Object[] arg2, MethodProxy arg3) throws Throwable &#123; MonitorSession.begin(arg1.getName()); Object obj = arg3.invokeSuper(arg0, arg2); MonitorSession.end(); return obj; &#125;&#125; 类似的通过getProxy可以得到这个代理对象，intercept就是具体的执行方法，可以看到我们在执行每个真正的方法前后都加了Monitor。 在工厂类中增加获得Person代理类的方法, 12345public static Person newCglibProxy() &#123; CGLibProxy cglibProxy = CGLibProxy.getInstance(); Person proxy = cglibProxy.getProxy(Person.class); return proxy;&#125; 具体使用 12345// cglib dynamic proxySystem.out.println("******** cglib proxy ******** ");Person cglibProxy = PersonProxyFactory.newCglibProxy();cglibProxy.sayHi();cglibProxy.sayBye(); 输出结果： 12345678begin monitor..Hi!!end monitor..Method: sayHi, execution time: 53 milliseconds.begin monitor..Bye!!end monitor..Method: sayBye, execution time: 14 milliseconds. 小结对比JDK动态代理和CGLib代理，在实际使用中发现CGLib在创建代理对象时所花费的时间却比JDK动态代理要长，实测数据 12Method: newJdkProxy, execution time: 5 milliseconds.Method: newCglibProxy, execution time: 18 milliseconds. 所以CGLib更适合代理不需要频繁实例化的类。 在具体方法执行效率方面，理应是不通过反射的CGlib更快一些，然后测试结果并非如此，还需要高手指教。 1234JDKMethod: sayHi, execution time: 32 milliseconds.CGLibMethod: sayHi, execution time: 53 milliseconds. 以上code都可以通过Github中获取。 转自Spring AOP的实现机制]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>aop</tag>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java NIO]]></title>
    <url>%2F2016%2F07%2F16%2FJava-NIO%2F</url>
    <content type="text"><![CDATA[NIO模型原理Channel: Channel是一个在TCP连接之间的抽象，一个TCP链接可以对应多个管道，而不是以前的方式只有一个通信信道，减少了TCP连接次数。 UDP：采用相同方式，也是抽象为管道。 通过selector(选择器)，相当于管家，管理所有的IO事件(Connection/accept，客户端服务端的读写等)。 Selector管理IO事件当IO事件注册给selector时，selector会给它们分配key值(可以简单理解为事件的标签), 当I/O事件完成后，会通过key值找到相应的管道，然后通过管道发送数据和接受数据等操作. 数据缓冲区：通过bytebuffer， 提供了很多读写方法 put get 服务端：ServerSocketChannel客户端：SocketChannel选择器：Selector打开选择器：1Selector selector = Selector.open(); SelectionKey可以通过它来判断IO事件是否已经就绪，通过以下代码获得:1SelectionKey keys = Selector.selectedKeys(); 状态获取：key.isAccptable() - 是否可以接受客户端的连接key.isConnectionable() - 是否可以连接服务器key.isReadable() - 是否可读key.isWriteable() - 是否可写 如何注册channel.regist(Selector, SelectionKey.OP_Write);channel.regist(Selector, SelectionKey.OP_Read);channel.regist(Selector, SelectionKey.OP_Connect);channel.regist(Selector, SelectionKey.OP_Accept);]]></content>
  </entry>
  <entry>
    <title><![CDATA[JMS]]></title>
    <url>%2F2016%2F06%2F08%2FJMS%2F</url>
    <content type="text"><![CDATA[什么是JMS JMS是Java Message Servie的缩写 它是一个用于在不同的客户端之间传递消息的Java消息的中间件应用接口 它是处理生产者消费者问题的一种实现 它也是一种消息标准，允许应用组件在J2EE平台创建，发送，接受和读取消息 JMS和JDBC很像，Java只是提供了一个访问JMS服务器以及进行消息处理的API标准，它完全独立于中间件消息服务器，就像JDBC独立于Oracle/Mysql之类的数据库一样。 JMS的消息模型 P2P 端到端模型P2P模型的target是队列(Queue), 消息首先发送到队列中, 之后在从队列中发送给监听队列的客户端中。一个队列可以连接多个消息发送方和多个消息接收方, 但是一个消息只能发送给一个接受者。如果有多个接收方都在监听队列中的消息, 那么JMS消息的发送将基于FCFS(First Come, First Server)原则。如果没有接收方监听队列, 那么消息将一直保存在队列中, 直到有接收方连接到队列。 Pub/Sub 发布订阅模型Pub/Sub模型中，一个消息可以从一个应用发送给多个接收者, 此时的target是topic。消息首先被发送至topic中, 之后会发送给所有订阅了该topic的接收者。 JMS的使用JMS API模块 Administered ObjectsAdministered Objects是预配置的JMS对象, 它有系统管理员创建, 用于管理Connection Factory和Destination。 Connection Factories客户端通过Connection Factory创建通JMS服务器之间的连接。JMS客户端会在JNDI命名空间中查找并创建连接, 通target之间建立连接之后, 就可以发送或者接收消息。 代码示例123QueueConnectionFactory factory = (QueueConnectionFactory)initialCxt.lookup("primaryQCF");Queue puchaseQueue = (Queue)initialCxt.lookup("Purchase_Queue");Queue returnQueue = (Queue)initialCtx.lookup("Return_Queue"); DestinationDestination指明消息发送的目标, 或者消息的来源, 可以是Queue也可以是Topic。 创建Queue代码示例:123QueueSession session = con.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);Queue queue = (Queue)ctx.lookup("myQueue");QueueReceiver receiver = session.createReceiver(queue); 创建Topic代码示例:123TopicSession session = con.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);Topic topic = (Topic)ctx.lookup("myTopic");TopicSubscriber receiver = session.createSubscriber(topic); ConnectionConnection用于连接JMS服务器。 1234//创建连接Connection connection = connectionFactory.createConnection();//关闭连接connection.close(); SessionsSession是一个单线程上下文对象, 用于创建生产者或者消费者。 12//创建SessionSession session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE); Message Producer消息生产者由Session创建，用于发送消息到Destination。 12345MessageProducer producer = session.createProducer(dest);MessageProducer producer2 = session.createProducer(queue);MessageProducer producer3 = session.createProducer(topic);producer.send(message); Message Consumers消息消费者也是由Session创建, 用于从Destination接收消息。 12345MessageConsummer consummer = session.createConsummer(dest);MessageConsummer consummer2 = session.createConsummer(queue);MessageConsummer consummer3 = session.createConsummer(topic);consummer.send(message); Message Listeners消息监听器是默认的事件处理器, 它是MessageListener接口的实现, 该接口中包含的onMessage方法用于处理消息发送成功之后的处理逻辑。 12Listener myListener = new Listener();Consummer.setMessageListener(myListener); JMS消息结构JMS客户端通过JMS消息同JMS服务器进行交互, JMS消息包括以下3部分: Message Header 消息头消息头中预定义了一些字段用于JMS客户端和JMS服务器之间的识别和消息传送。 消息头： JMSDestination JMSDeliveryMode JMSMessageID JMSTimestamp JMSCorrelationID JMSReplyTo JMSRedelivered JMSType JMSExpiration JMSPriority Message Property 消息属性消息属性可以由用户自定义，主要是提供给应用程序使用, 可以用于消息过滤。JMS API提供的也有一些标准的属性信息。 Message Body 消息体JMS提供的消息体有以下5种： Text Messagejavax.jms.TextMessage Object Messagejavax.jms.ObjectMessage Bytes Messagejavax.jms.BytesMessage Stream Messagejavax.jms.streamMessage Map Messagejavax.jms.MapMessage JMS的使用示例Tomcat + JNDI + ActiveMQ P2P Tomcat + JNDI + ActiveMQ Pub/Sub]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>JMS</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用服务器集群几种基本实现方式]]></title>
    <url>%2F2015%2F07%2F29%2F%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[负载均衡是网站必不可少的基础技术手段，不但可以实现网站的伸缩性，还可以改善网站的可用性。负载均衡的实现技术也有多种多样，从硬件到软件，从商业产品到开源软件，多不胜数，主要实现负载均衡的基础技术有以下几种： HTTP重定向负载均衡HTTP重定向服务器时一台普通的应用服务器，唯一的功能就是根据用户的HTTP请求计算出一台真实的Web服务器地址，并将该Web服务器地址写入HTTP重定向响应中(响应状态码302)返回给用户浏览器，然后浏览器自动重新请求实际的物理服务器IP地址，从而完成访问。 这种实现方案优点是比较简单，缺点是浏览器需要两次请求服务器才能完成一次访问，性能比较差。重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限。而且使用HTTP302响应吗重定向有可能使搜索引擎判断为SEO作弊，降低搜索排名。 DNS域名解析负载均衡这是利用DNS处理域名解析请求的同时进行负载均衡处理的一种方案。在DNS服务器中对指定域名配置多个ip地址，每次域名解析请求都会根据负载均衡算法计算出一个不同的IP地址，这样配置的多个服务器就构成一个集群，并且可以实现负载均衡。 DNS域名解析负载均衡的优点是将负载均衡的工作转交给DNS，省掉了网站管理维护负载均衡服务器的麻烦，同时许多DNS还支持基于地理位置的域名解析，即会将域名解析成距离用户地理最近的一个服务器地址，这样可以加速用户访问速度，改善性能。DNS域名解析负载均衡的缺点是目前的DNS是多级解析，每一级DNS都可能缓存，当下线了某台服务器后，即使修改了DNS中的记录，要使其生效也需要很长时间，这段时间，DNS依然会将域名解析道已经下线的服务器，从而导致用户访问失败。而且DNS负载均衡的控制权在域名服务商那里，网站无法对其做更多的改善和更强大的管理。 实际上，很多大型网站总是部分使用DNS域名解析，利用域名解析作为第一级负载均衡手段，即域名解析得到的一组服务器并不是实际提供Web服务的物理服务器，而是同样提供负载均衡服务的内部服务器，这组内部负载均衡服务器再进行负载均衡，将请求分发到真实的Web服务器上。 反向代理负载均衡反向代理服务器位于服务器端，正好是负载均衡服务器的位置，所以大多数反向代理服务器同时提供负载均衡的功能，管理一组Web服务器，将请求根据负载均衡算法转发到不同的Web服务器上，Web服务器处理完成的响应请求也需要通过反向代理服务器返回给用户。由于Web服务器不直接对外提供访问，因此Web服务器不需要使用外部IP地址，而反向代理则需要配置双网卡和内部外部两套IP地址。 反向代理负载均衡的优点是负载均衡和反向代理服务器功能集成在一起，部署简单。缺点时反向代理服务器是所有请求和响应的中转站，性能可能会成为瓶颈。 IP负载均衡IP负载均衡的原理是在网络层通过修改请求目标地址进行负载均衡。用户请求数据包达到负载均衡服务器之后，负载均衡服务器在操作系统内核进程获取网络数据包，根据负载均衡算法计算得到真实的Web服务器IP地址，然后将数据目的IP地址修改为真实的Web服务器地址，不需要通过用户进程处理。真实Web应用服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器再将数据包源地址修改为自身的IP地址发送给用户浏览器。 这里的关键在于真实物理Web服务器响应数据如何返回给负载均衡服务器。一种方案是负载均衡服务器修改目的IP地址的同时修改源地址，将数据包源地址设为自身的IP地址，即源地址转换(SNAT), 这样Web服务器的响应会再回到负载均衡服务器；另一种方案是负载均衡服务器同时作为真实物理服务器集群的网关服务器，这样所有的响应数据都会达到负载均衡服务器。 IP负载均衡在内核进程完成数据分发，比反向代理负载均衡有更好的处理性能。但是由于所有请求响应都需要经过负载均衡服务器，集群的最大响应数据吞吐量不得不受制于负载均衡服务器网卡带宽。对于提供下载服务或者是视频服务等需要传输大量数据的网站而言，难以满足需求。 数据链路层负载均衡数据链路层负载均衡是指在通信协议的数据链路层修改MAC地址进行负载均衡。负载均衡数据分发过程中不修改IP地址，之修改MAC地址，通过配置真实物理服务器集群所有机器虚拟IP和负载均衡服务器IP地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器IP地址和数据请求的目的IP一致，不需要经过负载均衡服务器进行地址转换，就可以把响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载均衡方式又称为直接路由方式。 这种方式是目前大型网站使用最广的一种负载均衡手段， Linux平台上最好的链路层负载均衡开源产品时LVS (Linux Virtual Server). 参考：《大型网站技术架构》 李智慧 著]]></content>
  </entry>
  <entry>
    <title><![CDATA[Web前端性能优化]]></title>
    <url>%2F2015%2F07%2F27%2FWeb%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一般来说，Web前端指网站业务逻辑之前的部分，包括浏览器加载，网站视图模型，图片服务，CDN服务等，主要的优化手段有以下几种： 减少http请求HTTP协议是无状态的应用层协议，意味着每次HTTP请求都需要建立通信链路，进行数据传输，而在服务端，每个HTTP请求都需要启动独立的线程去处理。这些通信和服务的开销都很昂贵，减少了HTTP请求的数目可以有效提高访问性能。 减少HTTP请求的主要手段： 合并CSS 合并Javascript 合并图片 使用浏览器缓存对于一个网站而言，CSS，Javascript，图标等静态资源文件的更新频率都比较低，但这些文件有几乎是每次页面请求都需要的，所以把这些静态资源缓存在浏览器中可以很好的改善网站的性能。通过设置HTTP请求头中的Cache-Control和Expires属性，可以设定浏览器缓存，缓存的时间可以是数天也可以是几个月。在有些时候静态资源文件变化需要及时应用到客户端浏览器，在这种情况下，可以通过改变文件命名来实现。 大量使用浏览器缓存策略的网站在更新静态资源时，应该用批量更新的方法，并有时间间隔，以免用户浏览器突然大量缓存失效，大量用户集中更新缓存，可能会造成服务器负载骤增及网络堵塞的状况。 服务端启用压缩在服务器端对文件进行压缩，在浏览器端对文件解压缩，可用有效减少通信传输的信息量。一般来说，启用GZIP等压缩方式可以对HTML，CSS，Javascript等文本文件达到80%的压缩率。 压缩对服务器和浏览器产生一定的压力，在通信带宽良好，而服务器资源不足的情况下要权衡考虑。 CSS引用放在页面最上方，Javascript引用放在页面最下方浏览器会在加载完全部CSS之后才会对整个页面进行渲染，因此最好的做法是把CSS引用放在页面最上方，让浏览器尽快下载完CSS文件。Javascript则相反，浏览器在加载Javascript之后立即执行，有可能会阻塞真个页面，造成页面显示缓慢。 如果页面解析时需要用到Javascript，这时放在页面底部就不合适了。 减少Cookie传输Cookie包含在每次请求和响应中，太大的Cookie会严重影响数据传输，因此哪些数据需要写入Cookie需要慎重考虑，尽量减少Cookie中传输的数据量。对于一些静态资源的访问，如CSS，Javascript等，发送Cookie是没有意义的，可以考虑静态资源使用独立域名访问，减少Cookie传输的次数。 CDN加速CDN(Content Distribute Network, 内容分发网络)的本质仍然是一个缓存，而且是将数据缓存在离用户最近的地方，使用户以最快速度获取数据。CDN可以缓存一般的静态资源，如图片，文件，CSS，Script脚本及静态网页等，这些都是访问频度比较高的文件，缓存在CDN可以极大改善网页的打开速度。 反向代理传统代理服务器位于浏览器一侧，代理浏览器将HTTP请求发送到互联网上，而反向代理服务器位于网站机房的一侧，代理网站Web服务器接收HTTP请求。来自互联网的请求必须经过代理服务器，相当于在Web服务器和外部网络之间建立了一个屏障，可以保护Web服务器防御外部的网络攻击，也可以配置缓存功能加速Web请求，而且还可以通过反向代理实现负载均衡的功能。 参考：《大型网站技术架构》 李智慧 著]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Web</tag>
        <tag>性能</tag>
        <tag>优化</tag>
      </tags>
  </entry>
</search>
